{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"KymFlow","text":"<p>Welcome to KymFlow, a tool for analyzing kymograph blood flow data.</p> <p>KymFlow provides both a desktop GUI application and a Python API for working with kymograph TIFF files, editing metadata, and performing Radon-based flow analysis.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide - Get started with KymFlow</li> <li>User Guide - Learn how to use the GUI</li> <li>API Reference - Programmatic access to kymograph data</li> <li>Examples - Jupyter notebook tutorials</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>GUI Application: Browse, analyze, and manage kymograph files with an intuitive interface</li> <li>Batch Processing: Analyze multiple files sequentially with progress tracking</li> <li>Metadata Management: Edit experimental metadata and save with analysis results</li> <li>Python API: Use the backend programmatically in scripts and notebooks</li> <li>Radon Flow Analysis: Detect flow direction and velocity using Radon transforms</li> </ul>"},{"location":"DEPLOYMENT/","title":"Deploying KymFlow Documentation to GitHub Pages","text":"<p>This guide explains how to deploy the MkDocs documentation site to GitHub Pages.</p>"},{"location":"DEPLOYMENT/#prerequisites","title":"Prerequisites","text":"<ul> <li>MkDocs and dependencies installed: <code>pip install -e \".[docs]\"</code></li> <li>Git repository with write access</li> <li>GitHub repository configured</li> </ul>"},{"location":"DEPLOYMENT/#manual-deployment","title":"Manual Deployment","text":""},{"location":"DEPLOYMENT/#first-time-setup","title":"First-Time Setup","text":"<ol> <li> <p>Build the documentation site: <pre><code>mkdocs build\n</code></pre>    This creates a <code>site/</code> directory with the static HTML files.</p> </li> <li> <p>Deploy to gh-pages branch: <pre><code>mkdocs gh-deploy\n</code></pre>    This command:</p> </li> <li>Builds the site</li> <li>Creates/updates the <code>gh-pages</code> branch</li> <li>Pushes to <code>origin/gh-pages</code></li> <li> <p>GitHub Pages will automatically serve from this branch</p> </li> <li> <p>Configure GitHub Pages (if not already done):</p> </li> <li>Go to repository Settings \u2192 Pages</li> <li>Source: Deploy from a branch</li> <li>Branch: <code>gh-pages</code> / <code>/ (root)</code></li> <li>Save</li> </ol>"},{"location":"DEPLOYMENT/#updating-documentation","title":"Updating Documentation","text":"<p>After making changes to documentation:</p> <pre><code>mkdocs gh-deploy\n</code></pre> <p>This will rebuild and redeploy the site.</p>"},{"location":"DEPLOYMENT/#automated-deployment","title":"Automated Deployment","text":"<p>See <code>.github/workflows/docs.yml</code> for the GitHub Actions workflow that automatically builds and deploys documentation when tags are pushed.</p>"},{"location":"DEPLOYMENT/#verification","title":"Verification","text":"<p>After deployment, the documentation will be available at: - <code>https://mapmanager.github.io/kymflow/</code></p> <p>(Replace <code>mapmanager</code> with your GitHub username/organization if different)</p>"},{"location":"DEPLOYMENT/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>404 errors: Ensure GitHub Pages is enabled and pointing to the <code>gh-pages</code> branch</li> <li>Build errors: Run <code>mkdocs build</code> locally first to catch errors</li> <li>Missing updates: Clear browser cache or wait a few minutes for GitHub to update</li> </ul>"},{"location":"about/","title":"About KymFlow","text":"<p>KymFlow is a tool for analyzing kymograph blood flow data from laser scanning microscopy experiments.</p>"},{"location":"about/#overview","title":"Overview","text":"<p>KymFlow provides both a desktop GUI application and a Python API for working with kymograph TIFF files. The tool enables researchers to:</p> <ul> <li>Load and visualize kymograph images</li> <li>Edit experimental metadata</li> <li>Perform Radon-based flow analysis to detect flow direction and velocity</li> <li>Process multiple files in batch mode</li> <li>Export analysis results for further processing</li> </ul>"},{"location":"about/#features","title":"Features","text":"<ul> <li>Intuitive GUI: Browse, analyze, and manage kymograph files with an easy-to-use interface</li> <li>Batch Processing: Analyze multiple files sequentially with progress tracking</li> <li>Metadata Management: Edit and save experimental metadata alongside analysis results</li> <li>Python API: Use the backend programmatically in scripts and Jupyter notebooks</li> <li>Radon Flow Analysis: Detect flow direction and velocity using Radon transforms</li> </ul>"},{"location":"about/#author","title":"Author","text":"<p>Robert H. Cudmore</p> <ul> <li>Email: robert.cudmore@gmail.com</li> <li>GitHub: mapmanager/kymflow</li> </ul>"},{"location":"about/#license","title":"License","text":"<p>This project is licensed under the GNU General Public License v3 or later (GPLv3+).</p> <p>See the LICENSE file for details.</p>"},{"location":"about/#citation","title":"Citation","text":"<p>If you use KymFlow in your research, please cite:</p> <pre><code>KymFlow: Kymograph Blood Flow Analysis Tool\nRobert H. Cudmore\nhttps://github.com/mapmanager/kymflow\n</code></pre>"},{"location":"about/#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please see the Contributing Guide for details on how to get started.</p>"},{"location":"about/#support","title":"Support","text":"<ul> <li>Issues: Report bugs or request features on GitHub Issues</li> <li>Documentation: Full documentation is available at https://mapmanager.github.io/kymflow/</li> </ul>"},{"location":"about/#acknowledgments","title":"Acknowledgments","text":"<p>KymFlow is designed for analyzing kymograph data from in vivo blood flow imaging experiments, particularly those using laser scanning microscopy techniques.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to KymFlow!</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/mapmanager/kymflow.git\ncd kymflow\n</code></pre></p> </li> <li> <p>Install in editable mode with development dependencies:    <pre><code>pip install -e \".[gui,test,notebook]\"\n</code></pre></p> </li> <li> <p>Run tests:    <pre><code>pytest\n</code></pre></p> </li> </ol>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Use type hints for function parameters and return values</li> <li>Add docstrings in Google style format</li> <li>Run linters before submitting PRs</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<ul> <li>Write tests for new features</li> <li>Ensure all tests pass: <code>pytest</code></li> <li>Aim for good test coverage of new code</li> <li>Tests should work without proprietary data when possible</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>Update docstrings when adding/changing functions</li> <li>Update user guide for GUI changes</li> <li>Update API docs for backend changes</li> <li>Keep examples in notebooks up to date</li> </ul>"},{"location":"contributing/#submitting-changes","title":"Submitting Changes","text":"<ol> <li>Create a feature branch</li> <li>Make your changes</li> <li>Add/update tests</li> <li>Run tests and ensure they pass</li> <li>Submit a pull request with a clear description</li> </ol>"},{"location":"download/","title":"Download KymFlow","text":"<p>KymFlow is available as a one-click desktop application for macOS.</p>"},{"location":"download/#download","title":"Download","text":"<p>Download the latest release from the GitHub Releases page.</p> <p>The macOS application is provided as a <code>.zip</code> file containing <code>KymFlow.app</code>.</p>"},{"location":"download/#installation-macos","title":"Installation (macOS)","text":""},{"location":"download/#step-1-download-and-extract","title":"Step 1: Download and Extract","text":"<ol> <li>Download the <code>KymFlow-macos-intel-*.zip</code> file from the releases page</li> <li>Uncompress the zip file (double-click or use <code>unzip</code> in Terminal)</li> <li>You should now have a <code>KymFlow.app</code> file</li> </ol>"},{"location":"download/#step-2-run-the-application-first-time","title":"Step 2: Run the Application (First Time)","text":"<p>macOS may show a warning about an \"unknown developer\" when you first try to open the app. This is normal for applications that aren't signed with an Apple Developer certificate. To run KymFlow:</p> <ol> <li>Option + Right-click (or Control + Click) on <code>KymFlow.app</code></li> <li>Select \"Open\" from the context menu</li> <li>You will see a warning dialog saying \"KymFlow is from an unidentified developer\"</li> <li>Click \"Open\" in the warning dialog</li> <li>The application will launch</li> </ol> <p>First Time Only</p> <p>You only need to do this once. After the first time, you can double-click <code>KymFlow.app</code> normally and it will open without any warnings.</p>"},{"location":"download/#alternative-method","title":"Alternative Method","text":"<p>If you prefer using Terminal:</p> <pre><code># Navigate to the folder containing KymFlow.app\ncd /path/to/KymFlow.app\n\n# Remove the quarantine attribute\nxattr -d com.apple.quarantine KymFlow.app\n\n# Now you can open it normally\nopen KymFlow.app\n</code></pre>"},{"location":"download/#system-requirements","title":"System Requirements","text":"<ul> <li>macOS: 10.13 (High Sierra) or later</li> <li>Architecture: Intel (x86_64)</li> <li>Python: Included in the app bundle (no separate installation needed)</li> </ul>"},{"location":"download/#troubleshooting","title":"Troubleshooting","text":""},{"location":"download/#app-wont-open","title":"App Won't Open","text":"<p>If the app still won't open after following the steps above:</p> <ol> <li>Check System Preferences \u2192 Security &amp; Privacy</li> <li>Look for a message about KymFlow being blocked</li> <li>Click \"Open Anyway\" if available</li> </ol>"},{"location":"download/#app-crashes-on-launch","title":"App Crashes on Launch","text":"<ul> <li>Check the Console app (Applications \u2192 Utilities \u2192 Console) for error messages</li> <li>Ensure you're running a supported macOS version</li> <li>Try downloading the latest release</li> </ul>"},{"location":"download/#alternative-install-from-source","title":"Alternative: Install from Source","text":"<p>If you prefer to install from source or need the latest development version, see the Installation Guide for instructions on installing via <code>uv</code> or <code>pip</code>.</p>"},{"location":"download/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: Report problems on GitHub Issues</li> <li>Documentation: See the User Guide for usage instructions</li> </ul>"},{"location":"api/kym_file/","title":"kymflow_core.kym_file","text":"<p>High-level API for working with kymograph TIFF files.</p> <p>This module provides the core data structures and functionality for loading, managing, and analyzing kymograph files. The main entry point is the <code>KymFile</code> class, which encapsulates raw image data, microscope metadata (Olympus txt), experimental metadata, and analysis products.</p> <p>The module is designed to support lazy loading - metadata queries do not require loading full TIFF data, making it efficient for browsing large collections of files. Analysis algorithms are pluggable through a consistent interface.</p> Example <p>Basic usage for loading and analyzing a kymograph file:</p> <pre><code>from kymflow_core.kym_file import KymFile\n\nkym = KymFile(\"/path/to/file.tif\", load_image=False)\ninfo = kym.to_metadata_dict(include_analysis=False)\nimage = kym.ensure_image_loaded()\nkym.analyze_flow(window_size=16)\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file-classes","title":"Classes","text":""},{"location":"api/kym_file/#kymflow_core.kym_file.AnalysisParameters","title":"<code>AnalysisParameters</code>  <code>dataclass</code>","text":"<p>Metadata describing analysis parameters and results.</p> <p>Stores information about the analysis algorithm used, its parameters, when it was run, and where results are saved. This metadata is saved alongside analysis results for reproducibility.</p> <p>Attributes:</p> Name Type Description <code>algorithm</code> <code>str</code> <p>Name of the analysis algorithm (e.g., \"mpRadon\").</p> <code>parameters</code> <code>Dict[str, Any]</code> <p>Dictionary of algorithm-specific parameters.</p> <code>analyzed_at</code> <code>Optional[datetime]</code> <p>Timestamp when analysis was performed.</p> <code>result_path</code> <code>Optional[Path]</code> <p>Path to the saved analysis results file (CSV).</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>@dataclass\nclass AnalysisParameters:\n    \"\"\"Metadata describing analysis parameters and results.\n\n    Stores information about the analysis algorithm used, its parameters,\n    when it was run, and where results are saved. This metadata is saved\n    alongside analysis results for reproducibility.\n\n    Attributes:\n        algorithm: Name of the analysis algorithm (e.g., \"mpRadon\").\n        parameters: Dictionary of algorithm-specific parameters.\n        analyzed_at: Timestamp when analysis was performed.\n        result_path: Path to the saved analysis results file (CSV).\n    \"\"\"\n\n    algorithm: str = field(\n        default=\"\",\n        metadata=field_metadata(\n            editable=False,\n            label=\"Algorithm\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    parameters: Dict[str, Any] = field(\n        default_factory=dict,\n        metadata=field_metadata(\n            editable=False,\n            label=\"Parameters\",\n            widget_type=\"text\",\n            grid_span=2,\n        ),\n    )\n    analyzed_at: Optional[datetime] = field(\n        default=None,\n        metadata=field_metadata(\n            editable=False,\n            label=\"Analyzed At\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    result_path: Optional[Path] = field(\n        default=None,\n        metadata=field_metadata(\n            editable=False,\n            label=\"Result Path\",\n            widget_type=\"text\",\n            grid_span=2,\n        ),\n    )\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary for serialization.\n\n        Returns:\n            Dictionary with all analysis parameters. Datetime is converted to\n            ISO format string, and Path is converted to string.\n        \"\"\"\n        return {\n            \"algorithm\": self.algorithm,\n            \"parameters\": self.parameters,\n            \"analyzed_at\": self.analyzed_at.isoformat() if self.analyzed_at else None,\n            \"result_path\": str(self.result_path) if self.result_path else None,\n        }\n\n    @classmethod\n    def form_schema(cls) -&gt; List[Dict[str, Any]]:\n        \"\"\"Return field schema for form generation.\n\n        Generates a list of field definitions with metadata extracted from\n        the dataclass field definitions. Used by GUI frameworks to dynamically\n        generate forms without hardcoding field information.\n\n        Returns:\n            List of dictionaries, each containing field name, label, editability,\n            widget type, grid span, visibility, and field type information.\n            Fields are ordered by their declaration order in the dataclass.\n        \"\"\"\n        schema = []\n        for field_obj in fields(cls):\n            meta = field_obj.metadata\n            schema.append(\n                {\n                    \"name\": field_obj.name,\n                    \"label\": meta.get(\n                        \"label\", field_obj.name.replace(\"_\", \" \").title()\n                    ),\n                    \"editable\": meta.get(\"editable\", True),\n                    \"widget_type\": meta.get(\"widget_type\", \"text\"),\n                    \"order\": meta.get(\"order\", 999),\n                    \"grid_span\": meta.get(\"grid_span\", 1),\n                    \"visible\": meta.get(\"visible\", True),\n                    \"field_type\": str(field_obj.type),\n                }\n            )\n\n        # Order is determined by the order of the fields in the dataclass\n        return schema\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.AnalysisParameters-functions","title":"Functions","text":""},{"location":"api/kym_file/#kymflow_core.kym_file.AnalysisParameters.form_schema","title":"<code>form_schema()</code>  <code>classmethod</code>","text":"<p>Return field schema for form generation.</p> <p>Generates a list of field definitions with metadata extracted from the dataclass field definitions. Used by GUI frameworks to dynamically generate forms without hardcoding field information.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of dictionaries, each containing field name, label, editability,</p> <code>List[Dict[str, Any]]</code> <p>widget type, grid span, visibility, and field type information.</p> <code>List[Dict[str, Any]]</code> <p>Fields are ordered by their declaration order in the dataclass.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>@classmethod\ndef form_schema(cls) -&gt; List[Dict[str, Any]]:\n    \"\"\"Return field schema for form generation.\n\n    Generates a list of field definitions with metadata extracted from\n    the dataclass field definitions. Used by GUI frameworks to dynamically\n    generate forms without hardcoding field information.\n\n    Returns:\n        List of dictionaries, each containing field name, label, editability,\n        widget type, grid span, visibility, and field type information.\n        Fields are ordered by their declaration order in the dataclass.\n    \"\"\"\n    schema = []\n    for field_obj in fields(cls):\n        meta = field_obj.metadata\n        schema.append(\n            {\n                \"name\": field_obj.name,\n                \"label\": meta.get(\n                    \"label\", field_obj.name.replace(\"_\", \" \").title()\n                ),\n                \"editable\": meta.get(\"editable\", True),\n                \"widget_type\": meta.get(\"widget_type\", \"text\"),\n                \"order\": meta.get(\"order\", 999),\n                \"grid_span\": meta.get(\"grid_span\", 1),\n                \"visible\": meta.get(\"visible\", True),\n                \"field_type\": str(field_obj.type),\n            }\n        )\n\n    # Order is determined by the order of the fields in the dataclass\n    return schema\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.AnalysisParameters.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary for serialization.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with all analysis parameters. Datetime is converted to</p> <code>Dict[str, Any]</code> <p>ISO format string, and Path is converted to string.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary for serialization.\n\n    Returns:\n        Dictionary with all analysis parameters. Datetime is converted to\n        ISO format string, and Path is converted to string.\n    \"\"\"\n    return {\n        \"algorithm\": self.algorithm,\n        \"parameters\": self.parameters,\n        \"analyzed_at\": self.analyzed_at.isoformat() if self.analyzed_at else None,\n        \"result_path\": str(self.result_path) if self.result_path else None,\n    }\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.ExperimentMetadata","title":"<code>ExperimentMetadata</code>  <code>dataclass</code>","text":"<p>User-provided experimental metadata for kymograph files.</p> <p>Contains structured fields for documenting experimental conditions, sample information, and notes. All fields are optional and have default values. Unknown keys in dictionaries are silently ignored when loading from dict to maintain strict schema validation.</p> <p>Attributes:</p> Name Type Description <code>species</code> <code>Optional[str]</code> <p>Animal species (e.g., \"mouse\", \"rat\").</p> <code>region</code> <code>Optional[str]</code> <p>Brain region or anatomical location.</p> <code>cell_type</code> <code>Optional[str]</code> <p>Type of cell or vessel being imaged.</p> <code>depth</code> <code>Optional[float]</code> <p>Imaging depth in micrometers.</p> <code>branch_order</code> <code>Optional[int]</code> <p>Branch order for vascular structures.</p> <code>direction</code> <code>Optional[str]</code> <p>Flow direction or vessel orientation.</p> <code>sex</code> <code>Optional[str]</code> <p>Animal sex.</p> <code>genotype</code> <code>Optional[str]</code> <p>Genetic background or modification.</p> <code>condition</code> <code>Optional[str]</code> <p>Experimental condition or treatment.</p> <code>acquisition_date</code> <code>Optional[str]</code> <p>Date of acquisition (read-only, from header).</p> <code>acquisition_time</code> <code>Optional[str]</code> <p>Time of acquisition (read-only, from header).</p> <code>note</code> <code>Optional[str]</code> <p>Free-form notes or comments.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>@dataclass\nclass ExperimentMetadata:\n    \"\"\"User-provided experimental metadata for kymograph files.\n\n    Contains structured fields for documenting experimental conditions,\n    sample information, and notes. All fields are optional and have default\n    values. Unknown keys in dictionaries are silently ignored when loading\n    from dict to maintain strict schema validation.\n\n    Attributes:\n        species: Animal species (e.g., \"mouse\", \"rat\").\n        region: Brain region or anatomical location.\n        cell_type: Type of cell or vessel being imaged.\n        depth: Imaging depth in micrometers.\n        branch_order: Branch order for vascular structures.\n        direction: Flow direction or vessel orientation.\n        sex: Animal sex.\n        genotype: Genetic background or modification.\n        condition: Experimental condition or treatment.\n        acquisition_date: Date of acquisition (read-only, from header).\n        acquisition_time: Time of acquisition (read-only, from header).\n        note: Free-form notes or comments.\n    \"\"\"\n\n    species: Optional[str] = field(\n        default=\"\",\n        metadata=field_metadata(\n            editable=True,\n            label=\"Species\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    region: Optional[str] = field(\n        default=\"\",\n        metadata=field_metadata(\n            editable=True,\n            label=\"Region\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    cell_type: Optional[str] = field(\n        default=\"\",\n        metadata=field_metadata(\n            editable=True,\n            label=\"Cell type\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    depth: Optional[float] = field(\n        default=None,\n        metadata=field_metadata(\n            editable=True,\n            label=\"Depth\",\n            widget_type=\"number\",\n            grid_span=1,\n        ),\n    )\n    branch_order: Optional[int] = field(\n        default=None,\n        metadata=field_metadata(\n            editable=True,\n            label=\"Branch order\",\n            widget_type=\"number\",\n            grid_span=1,\n        ),\n    )\n    direction: Optional[str] = field(\n        default=\"\",\n        metadata=field_metadata(\n            editable=True,\n            label=\"Direction\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    sex: Optional[str] = field(\n        default=\"\",\n        metadata=field_metadata(\n            editable=True,\n            label=\"Sex\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    genotype: Optional[str] = field(\n        default=\"\",\n        metadata=field_metadata(\n            editable=True,\n            label=\"Genotype\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    condition: Optional[str] = field(\n        default=\"\",\n        metadata=field_metadata(\n            editable=True,\n            label=\"Condition\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    acquisition_date: Optional[str] = field(\n        default=\"\",\n        metadata=field_metadata(\n            editable=False,\n            label=\"Acquisition Date\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    acquisition_time: Optional[str] = field(\n        default=\"\",\n        metadata=field_metadata(\n            editable=False,\n            label=\"Acquisition Time\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    note: Optional[str] = field(\n        default=\"\",\n        metadata=field_metadata(\n            editable=True,\n            label=\"Note\",\n            widget_type=\"text\",\n            grid_span=2,\n        ),\n    )\n\n    @classmethod\n    def from_dict(cls, payload: Optional[Dict[str, Any]]) -&gt; \"ExperimentMetadata\":\n        \"\"\"Create instance from dictionary, ignoring unknown keys.\n\n        Only fields defined in the dataclass are extracted from the payload.\n        Unknown keys are silently ignored to maintain strict schema validation.\n\n        Args:\n            payload: Dictionary containing metadata fields. Can be None or empty.\n\n        Returns:\n            ExperimentMetadata instance with values from payload, or defaults\n            if payload is None or empty.\n        \"\"\"\n        payload = payload or {}\n        valid = {f.name for f in fields(cls) if f.init}\n        known = {k: payload[k] for k in payload.keys() &amp; valid}\n        # Unknown keys are silently ignored (strict schema-only strategy)\n        return cls(**known)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary with standardized key names.\n\n        Returns:\n            Dictionary with field values, using abbreviated keys (acq_date,\n            acq_time) for compatibility with external APIs.\n        \"\"\"\n        return {\n            \"species\": self.species,\n            \"cell_type\": self.cell_type,\n            \"region\": self.region,\n            \"sex\": self.sex,\n            \"genotype\": self.genotype,\n            \"condition\": self.condition,\n            \"note\": self.note,\n            \"acq_date\": self.acquisition_date,\n            \"acq_time\": self.acquisition_time,\n        }\n\n    @classmethod\n    def form_schema(cls) -&gt; List[Dict[str, Any]]:\n        \"\"\"Return field schema for form generation.\n\n        Generates a list of field definitions with metadata extracted from\n        the dataclass field definitions. Used by GUI frameworks to dynamically\n        generate forms without hardcoding field information.\n\n        Returns:\n            List of dictionaries, each containing field name, label, editability,\n            widget type, grid span, visibility, and field type information.\n            Fields are ordered by their declaration order in the dataclass.\n        \"\"\"\n        schema = []\n        for field_obj in fields(cls):\n            meta = field_obj.metadata\n            schema.append(\n                {\n                    \"name\": field_obj.name,\n                    \"label\": meta.get(\n                        \"label\", field_obj.name.replace(\"_\", \" \").title()\n                    ),\n                    \"editable\": meta.get(\"editable\", True),\n                    \"widget_type\": meta.get(\"widget_type\", \"text\"),\n                    \"order\": meta.get(\"order\", 999),\n                    \"grid_span\": meta.get(\"grid_span\", 1),\n                    \"visible\": meta.get(\"visible\", True),\n                    \"field_type\": str(field_obj.type),\n                }\n            )\n\n        # order is determined by the order of the fields in the dataclass\n        # # Sort by order\n        # schema.sort(key=lambda x: x[\"order\"])\n        return schema\n\n    def get_editable_values(self) -&gt; Dict[str, str]:\n        \"\"\"Get current values for editable fields only.\n\n        Returns:\n            Dictionary mapping field names to string representations of their\n            current values. Only includes fields marked as editable in the\n            form schema. None values are converted to empty strings.\n        \"\"\"\n        schema = self.form_schema()\n        values = {}\n        for field_def in schema:\n            if field_def[\"editable\"]:\n                field_name = field_def[\"name\"]\n                values[field_name] = getattr(self, field_name) or \"\"\n        return values\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.ExperimentMetadata-functions","title":"Functions","text":""},{"location":"api/kym_file/#kymflow_core.kym_file.ExperimentMetadata.form_schema","title":"<code>form_schema()</code>  <code>classmethod</code>","text":"<p>Return field schema for form generation.</p> <p>Generates a list of field definitions with metadata extracted from the dataclass field definitions. Used by GUI frameworks to dynamically generate forms without hardcoding field information.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of dictionaries, each containing field name, label, editability,</p> <code>List[Dict[str, Any]]</code> <p>widget type, grid span, visibility, and field type information.</p> <code>List[Dict[str, Any]]</code> <p>Fields are ordered by their declaration order in the dataclass.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>@classmethod\ndef form_schema(cls) -&gt; List[Dict[str, Any]]:\n    \"\"\"Return field schema for form generation.\n\n    Generates a list of field definitions with metadata extracted from\n    the dataclass field definitions. Used by GUI frameworks to dynamically\n    generate forms without hardcoding field information.\n\n    Returns:\n        List of dictionaries, each containing field name, label, editability,\n        widget type, grid span, visibility, and field type information.\n        Fields are ordered by their declaration order in the dataclass.\n    \"\"\"\n    schema = []\n    for field_obj in fields(cls):\n        meta = field_obj.metadata\n        schema.append(\n            {\n                \"name\": field_obj.name,\n                \"label\": meta.get(\n                    \"label\", field_obj.name.replace(\"_\", \" \").title()\n                ),\n                \"editable\": meta.get(\"editable\", True),\n                \"widget_type\": meta.get(\"widget_type\", \"text\"),\n                \"order\": meta.get(\"order\", 999),\n                \"grid_span\": meta.get(\"grid_span\", 1),\n                \"visible\": meta.get(\"visible\", True),\n                \"field_type\": str(field_obj.type),\n            }\n        )\n\n    # order is determined by the order of the fields in the dataclass\n    # # Sort by order\n    # schema.sort(key=lambda x: x[\"order\"])\n    return schema\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.ExperimentMetadata.from_dict","title":"<code>from_dict(payload)</code>  <code>classmethod</code>","text":"<p>Create instance from dictionary, ignoring unknown keys.</p> <p>Only fields defined in the dataclass are extracted from the payload. Unknown keys are silently ignored to maintain strict schema validation.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>Optional[Dict[str, Any]]</code> <p>Dictionary containing metadata fields. Can be None or empty.</p> required <p>Returns:</p> Type Description <code>'ExperimentMetadata'</code> <p>ExperimentMetadata instance with values from payload, or defaults</p> <code>'ExperimentMetadata'</code> <p>if payload is None or empty.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>@classmethod\ndef from_dict(cls, payload: Optional[Dict[str, Any]]) -&gt; \"ExperimentMetadata\":\n    \"\"\"Create instance from dictionary, ignoring unknown keys.\n\n    Only fields defined in the dataclass are extracted from the payload.\n    Unknown keys are silently ignored to maintain strict schema validation.\n\n    Args:\n        payload: Dictionary containing metadata fields. Can be None or empty.\n\n    Returns:\n        ExperimentMetadata instance with values from payload, or defaults\n        if payload is None or empty.\n    \"\"\"\n    payload = payload or {}\n    valid = {f.name for f in fields(cls) if f.init}\n    known = {k: payload[k] for k in payload.keys() &amp; valid}\n    # Unknown keys are silently ignored (strict schema-only strategy)\n    return cls(**known)\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.ExperimentMetadata.get_editable_values","title":"<code>get_editable_values()</code>","text":"<p>Get current values for editable fields only.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dictionary mapping field names to string representations of their</p> <code>Dict[str, str]</code> <p>current values. Only includes fields marked as editable in the</p> <code>Dict[str, str]</code> <p>form schema. None values are converted to empty strings.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def get_editable_values(self) -&gt; Dict[str, str]:\n    \"\"\"Get current values for editable fields only.\n\n    Returns:\n        Dictionary mapping field names to string representations of their\n        current values. Only includes fields marked as editable in the\n        form schema. None values are converted to empty strings.\n    \"\"\"\n    schema = self.form_schema()\n    values = {}\n    for field_def in schema:\n        if field_def[\"editable\"]:\n            field_name = field_def[\"name\"]\n            values[field_name] = getattr(self, field_name) or \"\"\n    return values\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.ExperimentMetadata.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary with standardized key names.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with field values, using abbreviated keys (acq_date,</p> <code>Dict[str, Any]</code> <p>acq_time) for compatibility with external APIs.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary with standardized key names.\n\n    Returns:\n        Dictionary with field values, using abbreviated keys (acq_date,\n        acq_time) for compatibility with external APIs.\n    \"\"\"\n    return {\n        \"species\": self.species,\n        \"cell_type\": self.cell_type,\n        \"region\": self.region,\n        \"sex\": self.sex,\n        \"genotype\": self.genotype,\n        \"condition\": self.condition,\n        \"note\": self.note,\n        \"acq_date\": self.acquisition_date,\n        \"acq_time\": self.acquisition_time,\n    }\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.FieldMetadata","title":"<code>FieldMetadata</code>  <code>dataclass</code>","text":"<p>Structured metadata for form field definitions.</p> <p>Provides type-safe field metadata to avoid typos in metadata dictionaries. Used by GUI forms to configure field visibility, editability, and layout.</p> <p>Attributes:</p> Name Type Description <code>editable</code> <code>bool</code> <p>Whether the field can be edited by the user.</p> <code>label</code> <code>str</code> <p>Display label for the field.</p> <code>widget_type</code> <code>str</code> <p>Type of widget to use (e.g., \"text\", \"number\").</p> <code>grid_span</code> <code>int</code> <p>Number of grid columns this field spans.</p> <code>order</code> <code>Optional[int]</code> <p>Optional ordering value for field display.</p> <code>visible</code> <code>bool</code> <p>Whether the field should be visible in forms.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>@dataclass\nclass FieldMetadata:\n    \"\"\"Structured metadata for form field definitions.\n\n    Provides type-safe field metadata to avoid typos in metadata dictionaries.\n    Used by GUI forms to configure field visibility, editability, and layout.\n\n    Attributes:\n        editable: Whether the field can be edited by the user.\n        label: Display label for the field.\n        widget_type: Type of widget to use (e.g., \"text\", \"number\").\n        grid_span: Number of grid columns this field spans.\n        order: Optional ordering value for field display.\n        visible: Whether the field should be visible in forms.\n    \"\"\"\n\n    editable: bool = True\n    label: str = \"\"\n    widget_type: str = \"text\"\n    grid_span: int = 1\n    order: Optional[int] = None\n    visible: bool = True\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary for use in field(metadata=...).\n\n        Returns:\n            Dictionary containing all field metadata attributes, with None\n            values for order omitted.\n        \"\"\"\n        result = {\n            \"editable\": self.editable,\n            \"label\": self.label,\n            \"widget_type\": self.widget_type,\n            \"grid_span\": self.grid_span,\n            \"visible\": self.visible,\n        }\n        if self.order is not None:\n            result[\"order\"] = self.order\n        return result\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.FieldMetadata-functions","title":"Functions","text":""},{"location":"api/kym_file/#kymflow_core.kym_file.FieldMetadata.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary for use in field(metadata=...).</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing all field metadata attributes, with None</p> <code>Dict[str, Any]</code> <p>values for order omitted.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary for use in field(metadata=...).\n\n    Returns:\n        Dictionary containing all field metadata attributes, with None\n        values for order omitted.\n    \"\"\"\n    result = {\n        \"editable\": self.editable,\n        \"label\": self.label,\n        \"widget_type\": self.widget_type,\n        \"grid_span\": self.grid_span,\n        \"visible\": self.visible,\n    }\n    if self.order is not None:\n        result[\"order\"] = self.order\n    return result\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile","title":"<code>KymFile</code>","text":"<p>Encapsulates a kymograph TIFF file with metadata and analysis.</p> <p>This class provides a unified interface for working with kymograph files, including lazy loading of image data, metadata management, and flow analysis. The class is designed to support efficient metadata-only workflows where full image data is not needed.</p> <p>Always use KymFile properties and methods rather than accessing internal data structures directly. Key properties include:</p> <ul> <li><code>duration_seconds</code>: Total recording duration in seconds</li> <li><code>pixels_per_line</code>: Number of pixels per line (spatial dimension)</li> <li><code>num_lines</code>: Number of lines (time dimension)</li> <li><code>acquisition_metadata</code>: OlympusHeader with metadata (seconds_per_line, um_per_pixel, etc.)</li> <li><code>ensure_image_loaded()</code>: Load and return the image array</li> </ul> <p>Attributes:</p> Name Type Description <code>path</code> <p>Path to the TIFF file.</p> <code>experiment_metadata</code> <code>ExperimentMetadata</code> <p>User-provided experimental metadata.</p> <code>acquisition_metadata</code> <code>OlympusHeader</code> <p>Olympus microscope header data.</p> <code>analysis_parameters</code> <code>AnalysisParameters</code> <p>Parameters and results from flow analysis.</p> Example <pre><code>kym = KymFile(\"file.tif\", load_image=False)\nduration = kym.duration_seconds\npixels = kym.pixels_per_line\nimage = kym.ensure_image_loaded()\n</code></pre> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>class KymFile:\n    \"\"\"Encapsulates a kymograph TIFF file with metadata and analysis.\n\n    This class provides a unified interface for working with kymograph files,\n    including lazy loading of image data, metadata management, and flow analysis.\n    The class is designed to support efficient metadata-only workflows where\n    full image data is not needed.\n\n    Always use KymFile properties and methods rather than accessing internal\n    data structures directly. Key properties include:\n\n    - `duration_seconds`: Total recording duration in seconds\n    - `pixels_per_line`: Number of pixels per line (spatial dimension)\n    - `num_lines`: Number of lines (time dimension)\n    - `acquisition_metadata`: OlympusHeader with metadata (seconds_per_line, um_per_pixel, etc.)\n    - `ensure_image_loaded()`: Load and return the image array\n\n    Attributes:\n        path: Path to the TIFF file.\n        experiment_metadata: User-provided experimental metadata.\n        acquisition_metadata: Olympus microscope header data.\n        analysis_parameters: Parameters and results from flow analysis.\n\n    Example:\n        ```python\n        kym = KymFile(\"file.tif\", load_image=False)\n        duration = kym.duration_seconds\n        pixels = kym.pixels_per_line\n        image = kym.ensure_image_loaded()\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        path: str | Path,\n        *,\n        load_image: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize KymFile instance.\n\n        Loads metadata from the TIFF file and accompanying Olympus header file\n        if available. Optionally loads the image data immediately if requested.\n        Analysis data is automatically loaded if available.\n\n        Args:\n            path: Path to the kymograph TIFF file.\n            load_image: If True, load the TIFF image data immediately. If False,\n                image will be loaded lazily when needed. Defaults to False for\n                efficient metadata-only workflows.\n        \"\"\"\n        self.path = Path(path)\n        self._image: Optional[np.ndarray] = None\n\n        self._experiment_metadata: ExperimentMetadata = ExperimentMetadata()\n        self._header: OlympusHeader = OlympusHeader()  # header is default values\n\n        self._analysis_parameters: AnalysisParameters = AnalysisParameters()\n\n        self._dfAnalysis: Optional[pd.DataFrame] = None  # full df loaded from csv file\n\n        # try and load Olympus header from txt file if it exists\n        self._header = OlympusHeader.from_tif(self.path)\n\n        self.load_analysis()\n\n        if load_image:\n            self.ensure_image_loaded()\n\n        self._dirty: bool = False\n\n    def __str__(self) -&gt; str:\n        return f\"KymFile(filename: {self.path.name})\"\n\n    def summary_row(self) -&gt; Dict[str, Any]:\n        \"\"\"Generate tabular summary for file list views.\n\n        Returns a dictionary with key metadata fields formatted for display\n        in table views. Includes file name, folder hierarchy, analysis status,\n        and key acquisition parameters.\n\n        Returns:\n            Dictionary with keys suitable for table display, including file\n            name, folder names, analysis status, and metadata values.\n        \"\"\"\n        return {\n            \"File Name\": self.path.name,\n            \"Parent Folder\": self.path.parent.name,\n            \"Grandparent Folder\": self.path.parent.parent.name,\n            \"Analyzed\": \"\u2713\" if self.analysisExists else \"\",\n            \"Saved\": \"\u2713\" if not self._dirty else \"\",\n            \"Window Points\": self._analysis_parameters.parameters.get(\n                \"window_size\", \"-\"\n            ),\n            \"pixels\": self.pixels_per_line or \"-\",\n            \"lines\": self.num_lines or \"-\",\n            \"duration (s)\": self.duration_seconds or \"-\",\n            \"ms/line\": round(self._header.seconds_per_line * 1000, 2)\n            if self._header.seconds_per_line\n            else \"-\",\n            \"um/pixel\": self._header.um_per_pixel or \"-\",\n            \"bits/pixel\": self._header.bits_per_pixel or \"-\",\n            \"note\": self.experiment_metadata.note or \"-\",\n            \"path\": str(self.path),  # special case, not in any shema\n        }\n\n    @classmethod\n    def table_column_schema(cls) -&gt; Dict[str, bool]:\n        \"\"\"Return column visibility schema for table display.\n\n        Generates a dictionary mapping column names from summary_row() to\n        visibility flags. Reuses existing form schemas where possible to\n        avoid duplication of visibility rules.\n\n        Returns:\n            Dictionary mapping column names to boolean visibility flags.\n            Columns not in the mapping default to visible=True.\n        \"\"\"\n        # Mapping from summary_row keys to (dataclass_class, field_name) for schema lookup\n        # Keys not in this mapping are derived/computed fields\n        schema_field_mapping = {\n            \"note\": (ExperimentMetadata, \"note\"),\n            \"um/pixel\": (OlympusHeader, \"um_per_pixel\"),\n            # \"pixels\", \"lines\", \"duration (s)\", \"ms/line\" are derived from OlympusHeader\n            # but with different names, so we'd need property mappings - keeping simple for now\n        }\n\n        # Override dict for columns not in any schema (derived/computed fields)\n        # Defaults to True if not specified\n        visibility_overrides = {\n            \"path\": False,  # Always hide - used as row_key only\n            # All other columns default to visible=True (don't need to list them)\n        }\n\n        result = {}\n\n        # Look up visibility from existing form schemas\n        for col_name, (dataclass_cls, field_name) in schema_field_mapping.items():\n            form_schema = dataclass_cls.form_schema()\n            for field_def in form_schema:\n                if field_def[\"name\"] == field_name:\n                    result[col_name] = field_def.get(\"visible\", True)\n                    break\n\n        # Apply overrides (takes precedence)\n        result.update(visibility_overrides)\n\n        return result\n\n    # ------------------------------------------------------------------\n    # Loading helpers\n    # ------------------------------------------------------------------\n    def ensure_header_loaded(self) -&gt; OlympusHeader:\n        # header is always created in __init__\n        # so we don't need to check if it is None\n        # if self._header is None:\n        #     self._header = OlympusHeader.from_tif(self.path)\n        return self._header\n\n    def ensure_image_loaded(self) -&gt; np.ndarray:\n        \"\"\"Load and return the kymograph image data.\n\n        Implements lazy loading - the image is only loaded from disk when\n        this method is called. Subsequent calls return the cached image.\n        The image is flipped horizontally to match the expected orientation.\n\n        Returns:\n            2D numpy array with shape (time, space) where axis 0 is time\n            (line scans) and axis 1 is space (pixels).\n        \"\"\"\n        if self._image is None:\n            self._image = tifffile.imread(self.path)\n            # abb 20251121\n            self._image = np.flip(self._image, axis=1)\n\n        # logger.info(f'image loaded: {self._image.shape} dtype:{self._image.dtype}')\n\n        return self._image\n\n    # ------------------------------------------------------------------\n    # Metadata exposure\n    # ------------------------------------------------------------------\n    # abb not used\n    def to_metadata_dict(self, include_analysis: bool = True) -&gt; Dict[str, Any]:\n        \"\"\"Merge all metadata into a single dictionary.\n\n        Combines Olympus header data, experimental metadata, and optionally\n        analysis parameters into a unified dictionary structure. This is the\n        primary format consumed by GUI tables and CLI scripts.\n\n        Args:\n            include_analysis: If True, include analysis parameters in the\n                output. Defaults to True.\n\n        Returns:\n            Dictionary containing path, filename, and all metadata fields\n            from header, experiment metadata, and optionally analysis.\n        \"\"\"\n        header = (\n            self.ensure_header_loaded()\n        )  # header is always loaded in __init__ (can be default)\n        merged: Dict[str, Any] = {\n            \"path\": str(self.path),\n            \"filename\": self.path.name,\n            # \"filesize_bytes\": self.path.stat().st_size if self.path.exists() else None,\n        }\n        merged.update(header.to_dict())\n        merged.update(self._experiment_metadata.to_dict())\n        if include_analysis:\n            merged[\"analysis\"] = self._analysis_parameters.to_dict()\n        return merged\n\n    @property\n    def experiment_metadata(self) -&gt; ExperimentMetadata:\n        return self._experiment_metadata\n\n    @property\n    def acquisition_metadata(self) -&gt; OlympusHeader:\n        return self._header\n\n    @property\n    def analysis_parameters(self) -&gt; AnalysisParameters:\n        return self._analysis_parameters\n\n    def update_experiment_metadata(self, **fields: Any) -&gt; None:\n        \"\"\"Update stored experimental metadata fields.\n\n        Updates one or more fields in the experiment metadata. Unknown fields\n        are silently ignored. Marks the file as dirty (needs saving).\n\n        Args:\n            **fields: Keyword arguments mapping field names to new values.\n                Only fields that exist in ExperimentMetadata are updated.\n        \"\"\"\n        logger.info(f\"fields:{fields}\")\n        for key, value in fields.items():\n            if hasattr(self._experiment_metadata, key):\n                setattr(self._experiment_metadata, key, value)\n            # Unknown keys are silently ignored (strict schema-only strategy)\n        self._dirty = True\n\n    # ------------------------------------------------------------------\n    # Analysis hooks\n    # ------------------------------------------------------------------\n    def analyze_flow(\n        self,\n        window_size: int,\n        *,  # boundary between positional and keyword-only arguments\n        start_pixel: Optional[int] = None,\n        stop_pixel: Optional[int] = None,\n        progress_callback: Optional[ProgressCallback] = None,\n        is_cancelled: Optional[CancelCallback] = None,\n        use_multiprocessing: bool = True,\n    ) -&gt; None:\n        \"\"\"Run Radon-based flow analysis on the kymograph.\n\n        Performs a sliding window analysis along the time axis using Radon\n        transforms to detect flow direction and velocity. Results are stored\n        internally and can be saved using save_analysis(). The image must\n        be loaded before calling this method.\n\n        Args:\n            window_size: Number of time lines per analysis window. Must be\n                a multiple of 4.\n            start_pixel: Start index in space dimension (inclusive). If None,\n                uses 0.\n            stop_pixel: Stop index in space dimension (exclusive). If None,\n                uses full width.\n            progress_callback: Optional callback function(completed, total)\n                called periodically to report progress.\n            is_cancelled: Optional callback function() -&gt; bool that returns\n                True if analysis should be cancelled.\n            use_multiprocessing: If True, use multiprocessing for parallel\n                computation. Defaults to True.\n\n        Raises:\n            ValueError: If window_size is invalid or data dimensions are\n                incompatible.\n            FlowCancelled: If analysis is cancelled via is_cancelled callback.\n        \"\"\"\n        image = self.ensure_image_loaded()\n\n        thetas, the_t, spread = mp_analyze_flow(\n            image,\n            window_size,\n            start_pixel=start_pixel,\n            stop_pixel=stop_pixel,\n            progress_callback=progress_callback,\n            is_cancelled=is_cancelled,\n            use_multiprocessing=use_multiprocessing,\n        )\n        # Store lightweight metadata for UI access.\n        self._analysis_parameters = AnalysisParameters(\n            algorithm=\"mpRadon\",\n            parameters={\n                \"window_size\": window_size,\n                \"start_pixel\": start_pixel,\n                \"stop_pixel\": stop_pixel,\n                \"use_multiprocessing\": use_multiprocessing,\n            },\n            analyzed_at=datetime.now(timezone.utc),\n        )\n\n        secondsPerLine = self._header.seconds_per_line\n        umPerPixel = self._header.um_per_pixel\n\n        # convert to physical units\n        drewTime = the_t * secondsPerLine\n\n        # convert radians to angle\n        _rad = np.deg2rad(thetas)\n        drewVelocity = (umPerPixel / secondsPerLine) * np.tan(_rad)\n        drewVelocity = drewVelocity / 1000  # mm/s\n\n        # debug, count inf and 0 tan\n        # numZeros = np.count_nonzero(drewVelocity==0)\n        # logger.info(f'  1) numZeros:{numZeros}')\n\n        # remove inf and 0 tan()\n        # np.tan(90 deg) is returning 1e16 rather than inf\n        logger.info(\"not removing inf/0 velocity --&gt;&gt; use this to calculate stalls\")\n        # tan90or0 = (drewVelocity &gt; 1e6) | (drewVelocity == 0)\n        # drewVelocity[tan90or0] = float('nan')\n\n        # our original in kym_file_v0.py saved these columns:\n        # time,velocity,parentFolder,file,algorithm,delx,delt,numLines,pntsPerLine,cleanVelocity,absVelocity\n\n        cleanVelocity = _removeOutliers(drewVelocity)\n        cleanVelocity = _medianFilter(cleanVelocity, window_size=5)\n\n        self._dfAnalysis = pd.DataFrame(\n            {\n                \"time\": drewTime,\n                \"velocity\": drewVelocity,\n                \"parentFolder\": self.path.parent.name,\n                \"file\": self.path.name,\n                \"algorithm\": \"mpRadon\",\n                \"delx\": umPerPixel,\n                \"delt\": secondsPerLine,\n                \"numLines\": self.num_lines,\n                \"pntsPerLine\": self.pixels_per_line,\n                \"cleanVelocity\": cleanVelocity,  # what were these in v0\n                \"absVelocity\": abs(cleanVelocity),  # what were these in v0\n            }\n        )\n\n        # Mark as dirty so save_analysis() will save\n        self._dirty = True\n\n        # Auto-save analysis after successful computation\n        # self.save_analysis()\n\n    def save_analysis(self) -&gt; bool:\n        \"\"\"Save analysis results to CSV and JSON files.\n\n        Saves the analysis DataFrame to a CSV file and metadata to a JSON file\n        in the analysis folder (parent folder + '-analysis' suffix). Only saves\n        if the file is marked as dirty (has unsaved changes).\n\n        CSV contains: time, velocity, parentFolder, file, algorithm, delx, delt,\n        numLines, pntsPerLine, cleanVelocity, absVelocity.\n\n        JSON contains: OlympusHeader, ExperimentMetadata, AnalysisParameters.\n\n        Returns:\n            True if analysis was saved successfully, False if no analysis exists\n            or file is not dirty.\n        \"\"\"\n        if not self._dirty:\n            logger.info(f\"Analysis does not need to be for  {self.path.name}\")\n            return False\n\n        if not self.analysisExists:\n            logger.warning(f\"No analysis to save for {self.path.name}\")\n            return False\n\n        csv_path, json_path = _getSavePaths(self.path)\n\n        # our original in kym_file_v0.py saved these columns:\n        # time,velocity,parentFolder,file,algorithm,delx,delt,numLines,pntsPerLine,cleanVelocity,absVelocity\n\n        # Save CSV (no index, no header row)\n        self._dfAnalysis.to_csv(csv_path, index=False)\n        logger.info(f\"Saved analysis CSV to {csv_path}\")\n\n        # Build JSON metadata\n        metadata = {\n            \"olympus_header\": self.ensure_header_loaded().to_dict(),\n            \"experiment_metadata\": self._experiment_metadata.to_dict(),\n            \"analysis_parameters\": self._analysis_parameters.to_dict(),\n        }\n\n        # Save JSON\n        with open(json_path, \"w\") as f:\n            json.dump(metadata, f, indent=2, default=str)\n        logger.info(f\"Saved analysis metadata to {json_path}\")\n\n        # Update analysis snapshot with result path\n        self._analysis_parameters.result_path = csv_path\n\n        self._dirty = False\n        return True\n\n    def load_metadata(self) -&gt; bool:\n        \"\"\"Load metadata from saved JSON file.\n\n        Loads Olympus header, experiment metadata, and analysis parameters\n        from the JSON file in the analysis folder. Overwrites current metadata\n        if the file exists.\n\n        Returns:\n            True if metadata was loaded successfully, False if the JSON file\n            does not exist.\n        \"\"\"\n        _, json_path = _getSavePaths(self.path)\n        if not json_path.exists():\n            logger.info(f\"No metadata file found for {self.path.name}\")\n            return False\n\n        # Load JSON metadata\n        with open(json_path, \"r\") as f:\n            metadata = json.load(f)\n\n        # Restore OlympusHeader if not already loaded\n        if \"olympus_header\" in metadata:\n            header_data = metadata[\"olympus_header\"]\n            self._header = OlympusHeader(\n                um_per_pixel=header_data.get(\"um_per_pixel\"),\n                seconds_per_line=header_data.get(\"seconds_per_line\"),\n                duration_seconds=header_data.get(\"duration_seconds\"),\n                pixels_per_line=header_data.get(\"pixels_per_line\"),\n                num_lines=header_data.get(\"num_lines\"),\n                bits_per_pixel=header_data.get(\"bits_per_pixel\"),\n                date_str=header_data.get(\"date\"),\n                time_str=header_data.get(\"time\"),\n            )\n\n        # Restore ExperimentMetadata\n        if \"experiment_metadata\" in metadata:\n            bio_data = metadata[\"experiment_metadata\"]\n            self._experiment_metadata = ExperimentMetadata.from_dict(bio_data)\n\n        # Restore AnalysisParameters\n        if \"analysis_parameters\" in metadata:\n            snap_data = metadata[\"analysis_parameters\"]\n            analyzed_at_str = snap_data.get(\"analyzed_at\")\n            analyzed_at = (\n                datetime.fromisoformat(analyzed_at_str) if analyzed_at_str else None\n            )\n            self._analysis_parameters = AnalysisParameters(\n                algorithm=snap_data.get(\"algorithm\"),\n                parameters=snap_data.get(\"parameters\"),\n                analyzed_at=analyzed_at,\n                result_path=Path(snap_data[\"result_path\"])\n                if snap_data.get(\"result_path\")\n                else None,\n            )\n\n        return True\n\n    def load_analysis(self) -&gt; bool:\n        \"\"\"Load analysis results from CSV and JSON files.\n\n        Loads the analysis DataFrame from CSV and metadata from JSON in the\n        analysis folder. This is called automatically during initialization\n        if analysis files exist.\n\n        Returns:\n            True if analysis was loaded successfully, False if the CSV file\n            does not exist.\n        \"\"\"\n        csv_path, _ = _getSavePaths(self.path)\n\n        # Check if files exist\n        if not csv_path.exists():\n            logger.info(f\"No analysis files found for {self.path.name}\")\n            return False\n\n        # Load CSV into DataFrame\n        self._dfAnalysis = pd.read_csv(csv_path)\n\n        self.load_metadata()\n\n        # logger.info(f\"Loaded analysis for {self.path.name}\")\n        return True\n\n    @property\n    def analysisExists(self) -&gt; bool:\n        \"\"\"\n        Check if analysis has been loaded.\n        \"\"\"\n        return self._dfAnalysis is not None\n\n    def getAnalysisValue(self, key: str) -&gt; Any:\n        \"\"\"Get a value from the analysis DataFrame.\"\"\"\n        if self._dfAnalysis is None:\n            logger.warning(f\"No analysis loaded for {self.path.name}\")\n            return None\n        if key not in self._dfAnalysis.columns:\n            logger.warning(\n                f\"Key {key} not found in analysis DataFrame for {self.path.name}\"\n            )\n            logger.warning(f\"  Columns: {self._dfAnalysis.columns}\")\n            return None\n        return self._dfAnalysis[key].values\n\n    # ------------------------------------------------------------------\n    # Convenience information\n    # ------------------------------------------------------------------\n    @property\n    def num_lines(self) -&gt; Optional[int]:\n        \"\"\"Number of lines (time dimension) in the kymograph.\"\"\"\n        header = self.ensure_header_loaded()\n        return header.num_lines\n\n    @property\n    def pixels_per_line(self) -&gt; Optional[int]:\n        \"\"\"Number of pixels per line (spatial dimension) in the kymograph.\"\"\"\n        header = self.ensure_header_loaded()\n        return header.pixels_per_line\n\n    @property\n    def duration_seconds(self) -&gt; Optional[float]:\n        \"\"\"Total recording duration in seconds.\"\"\"\n        header = self.ensure_header_loaded()\n        return header.duration_seconds\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile-attributes","title":"Attributes","text":""},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.analysisExists","title":"<code>analysisExists</code>  <code>property</code>","text":"<p>Check if analysis has been loaded.</p>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.duration_seconds","title":"<code>duration_seconds</code>  <code>property</code>","text":"<p>Total recording duration in seconds.</p>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.num_lines","title":"<code>num_lines</code>  <code>property</code>","text":"<p>Number of lines (time dimension) in the kymograph.</p>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.pixels_per_line","title":"<code>pixels_per_line</code>  <code>property</code>","text":"<p>Number of pixels per line (spatial dimension) in the kymograph.</p>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile-functions","title":"Functions","text":""},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.__init__","title":"<code>__init__(path, *, load_image=False)</code>","text":"<p>Initialize KymFile instance.</p> <p>Loads metadata from the TIFF file and accompanying Olympus header file if available. Optionally loads the image data immediately if requested. Analysis data is automatically loaded if available.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the kymograph TIFF file.</p> required <code>load_image</code> <code>bool</code> <p>If True, load the TIFF image data immediately. If False, image will be loaded lazily when needed. Defaults to False for efficient metadata-only workflows.</p> <code>False</code> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def __init__(\n    self,\n    path: str | Path,\n    *,\n    load_image: bool = False,\n) -&gt; None:\n    \"\"\"Initialize KymFile instance.\n\n    Loads metadata from the TIFF file and accompanying Olympus header file\n    if available. Optionally loads the image data immediately if requested.\n    Analysis data is automatically loaded if available.\n\n    Args:\n        path: Path to the kymograph TIFF file.\n        load_image: If True, load the TIFF image data immediately. If False,\n            image will be loaded lazily when needed. Defaults to False for\n            efficient metadata-only workflows.\n    \"\"\"\n    self.path = Path(path)\n    self._image: Optional[np.ndarray] = None\n\n    self._experiment_metadata: ExperimentMetadata = ExperimentMetadata()\n    self._header: OlympusHeader = OlympusHeader()  # header is default values\n\n    self._analysis_parameters: AnalysisParameters = AnalysisParameters()\n\n    self._dfAnalysis: Optional[pd.DataFrame] = None  # full df loaded from csv file\n\n    # try and load Olympus header from txt file if it exists\n    self._header = OlympusHeader.from_tif(self.path)\n\n    self.load_analysis()\n\n    if load_image:\n        self.ensure_image_loaded()\n\n    self._dirty: bool = False\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.analyze_flow","title":"<code>analyze_flow(window_size, *, start_pixel=None, stop_pixel=None, progress_callback=None, is_cancelled=None, use_multiprocessing=True)</code>","text":"<p>Run Radon-based flow analysis on the kymograph.</p> <p>Performs a sliding window analysis along the time axis using Radon transforms to detect flow direction and velocity. Results are stored internally and can be saved using save_analysis(). The image must be loaded before calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>Number of time lines per analysis window. Must be a multiple of 4.</p> required <code>start_pixel</code> <code>Optional[int]</code> <p>Start index in space dimension (inclusive). If None, uses 0.</p> <code>None</code> <code>stop_pixel</code> <code>Optional[int]</code> <p>Stop index in space dimension (exclusive). If None, uses full width.</p> <code>None</code> <code>progress_callback</code> <code>Optional[ProgressCallback]</code> <p>Optional callback function(completed, total) called periodically to report progress.</p> <code>None</code> <code>is_cancelled</code> <code>Optional[CancelCallback]</code> <p>Optional callback function() -&gt; bool that returns True if analysis should be cancelled.</p> <code>None</code> <code>use_multiprocessing</code> <code>bool</code> <p>If True, use multiprocessing for parallel computation. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If window_size is invalid or data dimensions are incompatible.</p> <code>FlowCancelled</code> <p>If analysis is cancelled via is_cancelled callback.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def analyze_flow(\n    self,\n    window_size: int,\n    *,  # boundary between positional and keyword-only arguments\n    start_pixel: Optional[int] = None,\n    stop_pixel: Optional[int] = None,\n    progress_callback: Optional[ProgressCallback] = None,\n    is_cancelled: Optional[CancelCallback] = None,\n    use_multiprocessing: bool = True,\n) -&gt; None:\n    \"\"\"Run Radon-based flow analysis on the kymograph.\n\n    Performs a sliding window analysis along the time axis using Radon\n    transforms to detect flow direction and velocity. Results are stored\n    internally and can be saved using save_analysis(). The image must\n    be loaded before calling this method.\n\n    Args:\n        window_size: Number of time lines per analysis window. Must be\n            a multiple of 4.\n        start_pixel: Start index in space dimension (inclusive). If None,\n            uses 0.\n        stop_pixel: Stop index in space dimension (exclusive). If None,\n            uses full width.\n        progress_callback: Optional callback function(completed, total)\n            called periodically to report progress.\n        is_cancelled: Optional callback function() -&gt; bool that returns\n            True if analysis should be cancelled.\n        use_multiprocessing: If True, use multiprocessing for parallel\n            computation. Defaults to True.\n\n    Raises:\n        ValueError: If window_size is invalid or data dimensions are\n            incompatible.\n        FlowCancelled: If analysis is cancelled via is_cancelled callback.\n    \"\"\"\n    image = self.ensure_image_loaded()\n\n    thetas, the_t, spread = mp_analyze_flow(\n        image,\n        window_size,\n        start_pixel=start_pixel,\n        stop_pixel=stop_pixel,\n        progress_callback=progress_callback,\n        is_cancelled=is_cancelled,\n        use_multiprocessing=use_multiprocessing,\n    )\n    # Store lightweight metadata for UI access.\n    self._analysis_parameters = AnalysisParameters(\n        algorithm=\"mpRadon\",\n        parameters={\n            \"window_size\": window_size,\n            \"start_pixel\": start_pixel,\n            \"stop_pixel\": stop_pixel,\n            \"use_multiprocessing\": use_multiprocessing,\n        },\n        analyzed_at=datetime.now(timezone.utc),\n    )\n\n    secondsPerLine = self._header.seconds_per_line\n    umPerPixel = self._header.um_per_pixel\n\n    # convert to physical units\n    drewTime = the_t * secondsPerLine\n\n    # convert radians to angle\n    _rad = np.deg2rad(thetas)\n    drewVelocity = (umPerPixel / secondsPerLine) * np.tan(_rad)\n    drewVelocity = drewVelocity / 1000  # mm/s\n\n    # debug, count inf and 0 tan\n    # numZeros = np.count_nonzero(drewVelocity==0)\n    # logger.info(f'  1) numZeros:{numZeros}')\n\n    # remove inf and 0 tan()\n    # np.tan(90 deg) is returning 1e16 rather than inf\n    logger.info(\"not removing inf/0 velocity --&gt;&gt; use this to calculate stalls\")\n    # tan90or0 = (drewVelocity &gt; 1e6) | (drewVelocity == 0)\n    # drewVelocity[tan90or0] = float('nan')\n\n    # our original in kym_file_v0.py saved these columns:\n    # time,velocity,parentFolder,file,algorithm,delx,delt,numLines,pntsPerLine,cleanVelocity,absVelocity\n\n    cleanVelocity = _removeOutliers(drewVelocity)\n    cleanVelocity = _medianFilter(cleanVelocity, window_size=5)\n\n    self._dfAnalysis = pd.DataFrame(\n        {\n            \"time\": drewTime,\n            \"velocity\": drewVelocity,\n            \"parentFolder\": self.path.parent.name,\n            \"file\": self.path.name,\n            \"algorithm\": \"mpRadon\",\n            \"delx\": umPerPixel,\n            \"delt\": secondsPerLine,\n            \"numLines\": self.num_lines,\n            \"pntsPerLine\": self.pixels_per_line,\n            \"cleanVelocity\": cleanVelocity,  # what were these in v0\n            \"absVelocity\": abs(cleanVelocity),  # what were these in v0\n        }\n    )\n\n    # Mark as dirty so save_analysis() will save\n    self._dirty = True\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.ensure_image_loaded","title":"<code>ensure_image_loaded()</code>","text":"<p>Load and return the kymograph image data.</p> <p>Implements lazy loading - the image is only loaded from disk when this method is called. Subsequent calls return the cached image. The image is flipped horizontally to match the expected orientation.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>2D numpy array with shape (time, space) where axis 0 is time</p> <code>ndarray</code> <p>(line scans) and axis 1 is space (pixels).</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def ensure_image_loaded(self) -&gt; np.ndarray:\n    \"\"\"Load and return the kymograph image data.\n\n    Implements lazy loading - the image is only loaded from disk when\n    this method is called. Subsequent calls return the cached image.\n    The image is flipped horizontally to match the expected orientation.\n\n    Returns:\n        2D numpy array with shape (time, space) where axis 0 is time\n        (line scans) and axis 1 is space (pixels).\n    \"\"\"\n    if self._image is None:\n        self._image = tifffile.imread(self.path)\n        # abb 20251121\n        self._image = np.flip(self._image, axis=1)\n\n    # logger.info(f'image loaded: {self._image.shape} dtype:{self._image.dtype}')\n\n    return self._image\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.getAnalysisValue","title":"<code>getAnalysisValue(key)</code>","text":"<p>Get a value from the analysis DataFrame.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def getAnalysisValue(self, key: str) -&gt; Any:\n    \"\"\"Get a value from the analysis DataFrame.\"\"\"\n    if self._dfAnalysis is None:\n        logger.warning(f\"No analysis loaded for {self.path.name}\")\n        return None\n    if key not in self._dfAnalysis.columns:\n        logger.warning(\n            f\"Key {key} not found in analysis DataFrame for {self.path.name}\"\n        )\n        logger.warning(f\"  Columns: {self._dfAnalysis.columns}\")\n        return None\n    return self._dfAnalysis[key].values\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.load_analysis","title":"<code>load_analysis()</code>","text":"<p>Load analysis results from CSV and JSON files.</p> <p>Loads the analysis DataFrame from CSV and metadata from JSON in the analysis folder. This is called automatically during initialization if analysis files exist.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if analysis was loaded successfully, False if the CSV file</p> <code>bool</code> <p>does not exist.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def load_analysis(self) -&gt; bool:\n    \"\"\"Load analysis results from CSV and JSON files.\n\n    Loads the analysis DataFrame from CSV and metadata from JSON in the\n    analysis folder. This is called automatically during initialization\n    if analysis files exist.\n\n    Returns:\n        True if analysis was loaded successfully, False if the CSV file\n        does not exist.\n    \"\"\"\n    csv_path, _ = _getSavePaths(self.path)\n\n    # Check if files exist\n    if not csv_path.exists():\n        logger.info(f\"No analysis files found for {self.path.name}\")\n        return False\n\n    # Load CSV into DataFrame\n    self._dfAnalysis = pd.read_csv(csv_path)\n\n    self.load_metadata()\n\n    # logger.info(f\"Loaded analysis for {self.path.name}\")\n    return True\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.load_metadata","title":"<code>load_metadata()</code>","text":"<p>Load metadata from saved JSON file.</p> <p>Loads Olympus header, experiment metadata, and analysis parameters from the JSON file in the analysis folder. Overwrites current metadata if the file exists.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if metadata was loaded successfully, False if the JSON file</p> <code>bool</code> <p>does not exist.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def load_metadata(self) -&gt; bool:\n    \"\"\"Load metadata from saved JSON file.\n\n    Loads Olympus header, experiment metadata, and analysis parameters\n    from the JSON file in the analysis folder. Overwrites current metadata\n    if the file exists.\n\n    Returns:\n        True if metadata was loaded successfully, False if the JSON file\n        does not exist.\n    \"\"\"\n    _, json_path = _getSavePaths(self.path)\n    if not json_path.exists():\n        logger.info(f\"No metadata file found for {self.path.name}\")\n        return False\n\n    # Load JSON metadata\n    with open(json_path, \"r\") as f:\n        metadata = json.load(f)\n\n    # Restore OlympusHeader if not already loaded\n    if \"olympus_header\" in metadata:\n        header_data = metadata[\"olympus_header\"]\n        self._header = OlympusHeader(\n            um_per_pixel=header_data.get(\"um_per_pixel\"),\n            seconds_per_line=header_data.get(\"seconds_per_line\"),\n            duration_seconds=header_data.get(\"duration_seconds\"),\n            pixels_per_line=header_data.get(\"pixels_per_line\"),\n            num_lines=header_data.get(\"num_lines\"),\n            bits_per_pixel=header_data.get(\"bits_per_pixel\"),\n            date_str=header_data.get(\"date\"),\n            time_str=header_data.get(\"time\"),\n        )\n\n    # Restore ExperimentMetadata\n    if \"experiment_metadata\" in metadata:\n        bio_data = metadata[\"experiment_metadata\"]\n        self._experiment_metadata = ExperimentMetadata.from_dict(bio_data)\n\n    # Restore AnalysisParameters\n    if \"analysis_parameters\" in metadata:\n        snap_data = metadata[\"analysis_parameters\"]\n        analyzed_at_str = snap_data.get(\"analyzed_at\")\n        analyzed_at = (\n            datetime.fromisoformat(analyzed_at_str) if analyzed_at_str else None\n        )\n        self._analysis_parameters = AnalysisParameters(\n            algorithm=snap_data.get(\"algorithm\"),\n            parameters=snap_data.get(\"parameters\"),\n            analyzed_at=analyzed_at,\n            result_path=Path(snap_data[\"result_path\"])\n            if snap_data.get(\"result_path\")\n            else None,\n        )\n\n    return True\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.save_analysis","title":"<code>save_analysis()</code>","text":"<p>Save analysis results to CSV and JSON files.</p> <p>Saves the analysis DataFrame to a CSV file and metadata to a JSON file in the analysis folder (parent folder + '-analysis' suffix). Only saves if the file is marked as dirty (has unsaved changes).</p> <p>CSV contains: time, velocity, parentFolder, file, algorithm, delx, delt, numLines, pntsPerLine, cleanVelocity, absVelocity.</p> <p>JSON contains: OlympusHeader, ExperimentMetadata, AnalysisParameters.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if analysis was saved successfully, False if no analysis exists</p> <code>bool</code> <p>or file is not dirty.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def save_analysis(self) -&gt; bool:\n    \"\"\"Save analysis results to CSV and JSON files.\n\n    Saves the analysis DataFrame to a CSV file and metadata to a JSON file\n    in the analysis folder (parent folder + '-analysis' suffix). Only saves\n    if the file is marked as dirty (has unsaved changes).\n\n    CSV contains: time, velocity, parentFolder, file, algorithm, delx, delt,\n    numLines, pntsPerLine, cleanVelocity, absVelocity.\n\n    JSON contains: OlympusHeader, ExperimentMetadata, AnalysisParameters.\n\n    Returns:\n        True if analysis was saved successfully, False if no analysis exists\n        or file is not dirty.\n    \"\"\"\n    if not self._dirty:\n        logger.info(f\"Analysis does not need to be for  {self.path.name}\")\n        return False\n\n    if not self.analysisExists:\n        logger.warning(f\"No analysis to save for {self.path.name}\")\n        return False\n\n    csv_path, json_path = _getSavePaths(self.path)\n\n    # our original in kym_file_v0.py saved these columns:\n    # time,velocity,parentFolder,file,algorithm,delx,delt,numLines,pntsPerLine,cleanVelocity,absVelocity\n\n    # Save CSV (no index, no header row)\n    self._dfAnalysis.to_csv(csv_path, index=False)\n    logger.info(f\"Saved analysis CSV to {csv_path}\")\n\n    # Build JSON metadata\n    metadata = {\n        \"olympus_header\": self.ensure_header_loaded().to_dict(),\n        \"experiment_metadata\": self._experiment_metadata.to_dict(),\n        \"analysis_parameters\": self._analysis_parameters.to_dict(),\n    }\n\n    # Save JSON\n    with open(json_path, \"w\") as f:\n        json.dump(metadata, f, indent=2, default=str)\n    logger.info(f\"Saved analysis metadata to {json_path}\")\n\n    # Update analysis snapshot with result path\n    self._analysis_parameters.result_path = csv_path\n\n    self._dirty = False\n    return True\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.summary_row","title":"<code>summary_row()</code>","text":"<p>Generate tabular summary for file list views.</p> <p>Returns a dictionary with key metadata fields formatted for display in table views. Includes file name, folder hierarchy, analysis status, and key acquisition parameters.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with keys suitable for table display, including file</p> <code>Dict[str, Any]</code> <p>name, folder names, analysis status, and metadata values.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def summary_row(self) -&gt; Dict[str, Any]:\n    \"\"\"Generate tabular summary for file list views.\n\n    Returns a dictionary with key metadata fields formatted for display\n    in table views. Includes file name, folder hierarchy, analysis status,\n    and key acquisition parameters.\n\n    Returns:\n        Dictionary with keys suitable for table display, including file\n        name, folder names, analysis status, and metadata values.\n    \"\"\"\n    return {\n        \"File Name\": self.path.name,\n        \"Parent Folder\": self.path.parent.name,\n        \"Grandparent Folder\": self.path.parent.parent.name,\n        \"Analyzed\": \"\u2713\" if self.analysisExists else \"\",\n        \"Saved\": \"\u2713\" if not self._dirty else \"\",\n        \"Window Points\": self._analysis_parameters.parameters.get(\n            \"window_size\", \"-\"\n        ),\n        \"pixels\": self.pixels_per_line or \"-\",\n        \"lines\": self.num_lines or \"-\",\n        \"duration (s)\": self.duration_seconds or \"-\",\n        \"ms/line\": round(self._header.seconds_per_line * 1000, 2)\n        if self._header.seconds_per_line\n        else \"-\",\n        \"um/pixel\": self._header.um_per_pixel or \"-\",\n        \"bits/pixel\": self._header.bits_per_pixel or \"-\",\n        \"note\": self.experiment_metadata.note or \"-\",\n        \"path\": str(self.path),  # special case, not in any shema\n    }\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.table_column_schema","title":"<code>table_column_schema()</code>  <code>classmethod</code>","text":"<p>Return column visibility schema for table display.</p> <p>Generates a dictionary mapping column names from summary_row() to visibility flags. Reuses existing form schemas where possible to avoid duplication of visibility rules.</p> <p>Returns:</p> Type Description <code>Dict[str, bool]</code> <p>Dictionary mapping column names to boolean visibility flags.</p> <code>Dict[str, bool]</code> <p>Columns not in the mapping default to visible=True.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>@classmethod\ndef table_column_schema(cls) -&gt; Dict[str, bool]:\n    \"\"\"Return column visibility schema for table display.\n\n    Generates a dictionary mapping column names from summary_row() to\n    visibility flags. Reuses existing form schemas where possible to\n    avoid duplication of visibility rules.\n\n    Returns:\n        Dictionary mapping column names to boolean visibility flags.\n        Columns not in the mapping default to visible=True.\n    \"\"\"\n    # Mapping from summary_row keys to (dataclass_class, field_name) for schema lookup\n    # Keys not in this mapping are derived/computed fields\n    schema_field_mapping = {\n        \"note\": (ExperimentMetadata, \"note\"),\n        \"um/pixel\": (OlympusHeader, \"um_per_pixel\"),\n        # \"pixels\", \"lines\", \"duration (s)\", \"ms/line\" are derived from OlympusHeader\n        # but with different names, so we'd need property mappings - keeping simple for now\n    }\n\n    # Override dict for columns not in any schema (derived/computed fields)\n    # Defaults to True if not specified\n    visibility_overrides = {\n        \"path\": False,  # Always hide - used as row_key only\n        # All other columns default to visible=True (don't need to list them)\n    }\n\n    result = {}\n\n    # Look up visibility from existing form schemas\n    for col_name, (dataclass_cls, field_name) in schema_field_mapping.items():\n        form_schema = dataclass_cls.form_schema()\n        for field_def in form_schema:\n            if field_def[\"name\"] == field_name:\n                result[col_name] = field_def.get(\"visible\", True)\n                break\n\n    # Apply overrides (takes precedence)\n    result.update(visibility_overrides)\n\n    return result\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.to_metadata_dict","title":"<code>to_metadata_dict(include_analysis=True)</code>","text":"<p>Merge all metadata into a single dictionary.</p> <p>Combines Olympus header data, experimental metadata, and optionally analysis parameters into a unified dictionary structure. This is the primary format consumed by GUI tables and CLI scripts.</p> <p>Parameters:</p> Name Type Description Default <code>include_analysis</code> <code>bool</code> <p>If True, include analysis parameters in the output. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing path, filename, and all metadata fields</p> <code>Dict[str, Any]</code> <p>from header, experiment metadata, and optionally analysis.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def to_metadata_dict(self, include_analysis: bool = True) -&gt; Dict[str, Any]:\n    \"\"\"Merge all metadata into a single dictionary.\n\n    Combines Olympus header data, experimental metadata, and optionally\n    analysis parameters into a unified dictionary structure. This is the\n    primary format consumed by GUI tables and CLI scripts.\n\n    Args:\n        include_analysis: If True, include analysis parameters in the\n            output. Defaults to True.\n\n    Returns:\n        Dictionary containing path, filename, and all metadata fields\n        from header, experiment metadata, and optionally analysis.\n    \"\"\"\n    header = (\n        self.ensure_header_loaded()\n    )  # header is always loaded in __init__ (can be default)\n    merged: Dict[str, Any] = {\n        \"path\": str(self.path),\n        \"filename\": self.path.name,\n        # \"filesize_bytes\": self.path.stat().st_size if self.path.exists() else None,\n    }\n    merged.update(header.to_dict())\n    merged.update(self._experiment_metadata.to_dict())\n    if include_analysis:\n        merged[\"analysis\"] = self._analysis_parameters.to_dict()\n    return merged\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.KymFile.update_experiment_metadata","title":"<code>update_experiment_metadata(**fields)</code>","text":"<p>Update stored experimental metadata fields.</p> <p>Updates one or more fields in the experiment metadata. Unknown fields are silently ignored. Marks the file as dirty (needs saving).</p> <p>Parameters:</p> Name Type Description Default <code>**fields</code> <code>Any</code> <p>Keyword arguments mapping field names to new values. Only fields that exist in ExperimentMetadata are updated.</p> <code>{}</code> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def update_experiment_metadata(self, **fields: Any) -&gt; None:\n    \"\"\"Update stored experimental metadata fields.\n\n    Updates one or more fields in the experiment metadata. Unknown fields\n    are silently ignored. Marks the file as dirty (needs saving).\n\n    Args:\n        **fields: Keyword arguments mapping field names to new values.\n            Only fields that exist in ExperimentMetadata are updated.\n    \"\"\"\n    logger.info(f\"fields:{fields}\")\n    for key, value in fields.items():\n        if hasattr(self._experiment_metadata, key):\n            setattr(self._experiment_metadata, key, value)\n        # Unknown keys are silently ignored (strict schema-only strategy)\n    self._dirty = True\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.OlympusHeader","title":"<code>OlympusHeader</code>  <code>dataclass</code>","text":"<p>Structured representation of Olympus microscope header metadata.</p> <p>Contains acquisition parameters extracted from the Olympus .txt header file that accompanies kymograph TIFF files. All fields have default values to handle cases where the header file is missing.</p> <p>Attributes:</p> Name Type Description <code>um_per_pixel</code> <code>Optional[float]</code> <p>Spatial resolution in micrometers per pixel.</p> <code>seconds_per_line</code> <code>Optional[float]</code> <p>Temporal resolution in seconds per line scan.</p> <code>duration_seconds</code> <code>Optional[float]</code> <p>Total recording duration in seconds.</p> <code>pixels_per_line</code> <code>Optional[int]</code> <p>Number of pixels in the spatial dimension.</p> <code>num_lines</code> <code>Optional[int]</code> <p>Number of line scans in the temporal dimension.</p> <code>bits_per_pixel</code> <code>Optional[int]</code> <p>Bit depth of the image data.</p> <code>date_str</code> <code>Optional[str]</code> <p>Acquisition date string from header.</p> <code>time_str</code> <code>Optional[str]</code> <p>Acquisition time string from header.</p> <code>raw</code> <code>Dict[str, Any]</code> <p>Raw dictionary of all parsed header values.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>@dataclass\nclass OlympusHeader:\n    \"\"\"Structured representation of Olympus microscope header metadata.\n\n    Contains acquisition parameters extracted from the Olympus .txt header file\n    that accompanies kymograph TIFF files. All fields have default values to\n    handle cases where the header file is missing.\n\n    Attributes:\n        um_per_pixel: Spatial resolution in micrometers per pixel.\n        seconds_per_line: Temporal resolution in seconds per line scan.\n        duration_seconds: Total recording duration in seconds.\n        pixels_per_line: Number of pixels in the spatial dimension.\n        num_lines: Number of line scans in the temporal dimension.\n        bits_per_pixel: Bit depth of the image data.\n        date_str: Acquisition date string from header.\n        time_str: Acquisition time string from header.\n        raw: Raw dictionary of all parsed header values.\n    \"\"\"\n\n    # OlympusHeader needs defaults in case corresponding Olympus txt file is not found\n    um_per_pixel: Optional[float] = field(\n        default=1.0,\n        metadata=field_metadata(\n            editable=False,\n            label=\"um/pixel\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    seconds_per_line: Optional[float] = field(\n        default=0.001,  # 1 ms\n        metadata=field_metadata(\n            editable=False,\n            label=\"seconds/line\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    duration_seconds: Optional[float] = field(\n        default=None,\n        metadata=field_metadata(\n            editable=False,\n            label=\"Duration (s)\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    pixels_per_line: Optional[int] = field(\n        default=None,\n        metadata=field_metadata(\n            editable=False,\n            label=\"Pixels/Line\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    num_lines: Optional[int] = field(\n        default=None,\n        metadata=field_metadata(\n            editable=False,\n            label=\"Lines\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    bits_per_pixel: Optional[int] = field(\n        default=None,\n        metadata=field_metadata(\n            editable=False,\n            label=\"Bits/Pixel\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    date_str: Optional[str] = field(\n        default=None,\n        metadata=field_metadata(\n            editable=False,\n            label=\"Date\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    time_str: Optional[str] = field(\n        default=None,\n        metadata=field_metadata(\n            editable=False,\n            label=\"Time\",\n            widget_type=\"text\",\n            grid_span=1,\n        ),\n    )\n    raw: Dict[str, Any] = field(\n        default_factory=dict,\n        metadata=field_metadata(\n            editable=False,\n            label=\"Raw\",\n            widget_type=\"text\",\n            grid_span=2,  # Full width for raw dict\n            visible=False,  # Hide raw dict from form display\n        ),\n    )\n\n    @classmethod\n    def from_tif(cls, tif_path: Path) -&gt; \"OlympusHeader\":\n        \"\"\"Load Olympus header from accompanying .txt file.\n\n        Attempts to parse the Olympus header file that should be in the same\n        directory as the TIFF file with the same base name. Returns a header\n        with default values if the file is not found or cannot be parsed.\n\n        Args:\n            tif_path: Path to the TIFF file. The corresponding .txt file will\n                be looked up in the same directory.\n\n        Returns:\n            OlympusHeader instance with parsed values, or default values if\n            the header file is missing.\n        \"\"\"\n        parsed = _readOlympusHeader(str(tif_path))\n        if not parsed:\n            return cls()\n        return cls(\n            um_per_pixel=parsed.get(\"umPerPixel\"),\n            seconds_per_line=parsed.get(\"secondsPerLine\"),\n            duration_seconds=parsed.get(\"durImage_sec\"),\n            pixels_per_line=parsed.get(\"pixelsPerLine\"),\n            num_lines=parsed.get(\"numLines\"),\n            bits_per_pixel=parsed.get(\"bitsPerPixel\"),\n            date_str=parsed.get(\"dateStr\"),\n            time_str=parsed.get(\"timeStr\"),\n            raw=parsed,\n        )\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary with renamed keys.\n\n        Returns:\n            Dictionary representation with date_str and time_str renamed to\n            date and time for compatibility with external APIs.\n        \"\"\"\n        d = asdict(self)\n        # Rename keys\n        d[\"date\"] = d.pop(\"date_str\", None)\n        d[\"time\"] = d.pop(\"time_str\", None)\n        return d\n\n    @classmethod\n    def form_schema(cls) -&gt; List[Dict[str, Any]]:\n        \"\"\"Return field schema for form generation.\n\n        Generates a list of field definitions with metadata extracted from\n        the dataclass field definitions. Used by GUI frameworks to dynamically\n        generate forms without hardcoding field information.\n\n        Returns:\n            List of dictionaries, each containing field name, label, editability,\n            widget type, grid span, visibility, and field type information.\n            Fields are ordered by their declaration order in the dataclass.\n        \"\"\"\n        schema = []\n        for field_obj in fields(cls):\n            meta = field_obj.metadata\n            schema.append(\n                {\n                    \"name\": field_obj.name,\n                    \"label\": meta.get(\n                        \"label\", field_obj.name.replace(\"_\", \" \").title()\n                    ),\n                    \"editable\": meta.get(\"editable\", True),\n                    \"widget_type\": meta.get(\"widget_type\", \"text\"),\n                    \"order\": meta.get(\"order\", 999),\n                    \"grid_span\": meta.get(\"grid_span\", 1),\n                    \"visible\": meta.get(\"visible\", True),\n                    \"field_type\": str(field_obj.type),\n                }\n            )\n\n        # Order is determined by the order of the fields in the dataclass\n        return schema\n\n    def get_editable_values(self) -&gt; Dict[str, str]:\n        \"\"\"Get current values for editable fields only.\n\n        Returns:\n            Dictionary mapping field names to string representations of their\n            current values. Only includes fields marked as editable in the\n            form schema. None values are converted to empty strings.\n        \"\"\"\n        schema = self.form_schema()\n        values = {}\n        for field_def in schema:\n            if field_def[\"editable\"]:\n                field_name = field_def[\"name\"]\n                value = getattr(self, field_name)\n                # Convert to string, handling None and dict types\n                if value is None:\n                    values[field_name] = \"\"\n                elif isinstance(value, dict):\n                    values[field_name] = str(value)\n                else:\n                    values[field_name] = str(value)\n        return values\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.OlympusHeader-functions","title":"Functions","text":""},{"location":"api/kym_file/#kymflow_core.kym_file.OlympusHeader.form_schema","title":"<code>form_schema()</code>  <code>classmethod</code>","text":"<p>Return field schema for form generation.</p> <p>Generates a list of field definitions with metadata extracted from the dataclass field definitions. Used by GUI frameworks to dynamically generate forms without hardcoding field information.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of dictionaries, each containing field name, label, editability,</p> <code>List[Dict[str, Any]]</code> <p>widget type, grid span, visibility, and field type information.</p> <code>List[Dict[str, Any]]</code> <p>Fields are ordered by their declaration order in the dataclass.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>@classmethod\ndef form_schema(cls) -&gt; List[Dict[str, Any]]:\n    \"\"\"Return field schema for form generation.\n\n    Generates a list of field definitions with metadata extracted from\n    the dataclass field definitions. Used by GUI frameworks to dynamically\n    generate forms without hardcoding field information.\n\n    Returns:\n        List of dictionaries, each containing field name, label, editability,\n        widget type, grid span, visibility, and field type information.\n        Fields are ordered by their declaration order in the dataclass.\n    \"\"\"\n    schema = []\n    for field_obj in fields(cls):\n        meta = field_obj.metadata\n        schema.append(\n            {\n                \"name\": field_obj.name,\n                \"label\": meta.get(\n                    \"label\", field_obj.name.replace(\"_\", \" \").title()\n                ),\n                \"editable\": meta.get(\"editable\", True),\n                \"widget_type\": meta.get(\"widget_type\", \"text\"),\n                \"order\": meta.get(\"order\", 999),\n                \"grid_span\": meta.get(\"grid_span\", 1),\n                \"visible\": meta.get(\"visible\", True),\n                \"field_type\": str(field_obj.type),\n            }\n        )\n\n    # Order is determined by the order of the fields in the dataclass\n    return schema\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.OlympusHeader.from_tif","title":"<code>from_tif(tif_path)</code>  <code>classmethod</code>","text":"<p>Load Olympus header from accompanying .txt file.</p> <p>Attempts to parse the Olympus header file that should be in the same directory as the TIFF file with the same base name. Returns a header with default values if the file is not found or cannot be parsed.</p> <p>Parameters:</p> Name Type Description Default <code>tif_path</code> <code>Path</code> <p>Path to the TIFF file. The corresponding .txt file will be looked up in the same directory.</p> required <p>Returns:</p> Type Description <code>'OlympusHeader'</code> <p>OlympusHeader instance with parsed values, or default values if</p> <code>'OlympusHeader'</code> <p>the header file is missing.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>@classmethod\ndef from_tif(cls, tif_path: Path) -&gt; \"OlympusHeader\":\n    \"\"\"Load Olympus header from accompanying .txt file.\n\n    Attempts to parse the Olympus header file that should be in the same\n    directory as the TIFF file with the same base name. Returns a header\n    with default values if the file is not found or cannot be parsed.\n\n    Args:\n        tif_path: Path to the TIFF file. The corresponding .txt file will\n            be looked up in the same directory.\n\n    Returns:\n        OlympusHeader instance with parsed values, or default values if\n        the header file is missing.\n    \"\"\"\n    parsed = _readOlympusHeader(str(tif_path))\n    if not parsed:\n        return cls()\n    return cls(\n        um_per_pixel=parsed.get(\"umPerPixel\"),\n        seconds_per_line=parsed.get(\"secondsPerLine\"),\n        duration_seconds=parsed.get(\"durImage_sec\"),\n        pixels_per_line=parsed.get(\"pixelsPerLine\"),\n        num_lines=parsed.get(\"numLines\"),\n        bits_per_pixel=parsed.get(\"bitsPerPixel\"),\n        date_str=parsed.get(\"dateStr\"),\n        time_str=parsed.get(\"timeStr\"),\n        raw=parsed,\n    )\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.OlympusHeader.get_editable_values","title":"<code>get_editable_values()</code>","text":"<p>Get current values for editable fields only.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dictionary mapping field names to string representations of their</p> <code>Dict[str, str]</code> <p>current values. Only includes fields marked as editable in the</p> <code>Dict[str, str]</code> <p>form schema. None values are converted to empty strings.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def get_editable_values(self) -&gt; Dict[str, str]:\n    \"\"\"Get current values for editable fields only.\n\n    Returns:\n        Dictionary mapping field names to string representations of their\n        current values. Only includes fields marked as editable in the\n        form schema. None values are converted to empty strings.\n    \"\"\"\n    schema = self.form_schema()\n    values = {}\n    for field_def in schema:\n        if field_def[\"editable\"]:\n            field_name = field_def[\"name\"]\n            value = getattr(self, field_name)\n            # Convert to string, handling None and dict types\n            if value is None:\n                values[field_name] = \"\"\n            elif isinstance(value, dict):\n                values[field_name] = str(value)\n            else:\n                values[field_name] = str(value)\n    return values\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.OlympusHeader.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary with renamed keys.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary representation with date_str and time_str renamed to</p> <code>Dict[str, Any]</code> <p>date and time for compatibility with external APIs.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary with renamed keys.\n\n    Returns:\n        Dictionary representation with date_str and time_str renamed to\n        date and time for compatibility with external APIs.\n    \"\"\"\n    d = asdict(self)\n    # Rename keys\n    d[\"date\"] = d.pop(\"date_str\", None)\n    d[\"time\"] = d.pop(\"time_str\", None)\n    return d\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file-functions","title":"Functions","text":""},{"location":"api/kym_file/#kymflow_core.kym_file.collect_metadata","title":"<code>collect_metadata(root, **kwargs)</code>","text":"<p>Collect metadata for all TIFF files under a root directory.</p> <p>Convenience wrapper around iter_metadata() that collects all results into a list. Useful for GUI applications that need all metadata at once.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str | Path</code> <p>Root directory to search, or a single file path.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to iter_metadata() (glob, follow_symlinks, etc.).</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of metadata dictionaries, one per TIFF file found.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def collect_metadata(root: str | Path, **kwargs: Any) -&gt; List[Dict[str, Any]]:\n    \"\"\"Collect metadata for all TIFF files under a root directory.\n\n    Convenience wrapper around iter_metadata() that collects all results\n    into a list. Useful for GUI applications that need all metadata at once.\n\n    Args:\n        root: Root directory to search, or a single file path.\n        **kwargs: Additional arguments passed to iter_metadata() (glob,\n            follow_symlinks, etc.).\n\n    Returns:\n        List of metadata dictionaries, one per TIFF file found.\n    \"\"\"\n    return list(iter_metadata(root, **kwargs))\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.field_metadata","title":"<code>field_metadata(editable=True, label='', widget_type='text', grid_span=1, order=None, visible=True)</code>","text":"<p>Create field metadata dictionary.</p> <p>Convenience function that creates a FieldMetadata instance and converts it to a dictionary suitable for use in dataclass field metadata.</p> <p>Parameters:</p> Name Type Description Default <code>editable</code> <code>bool</code> <p>Whether the field can be edited by the user.</p> <code>True</code> <code>label</code> <code>str</code> <p>Display label for the field.</p> <code>''</code> <code>widget_type</code> <code>str</code> <p>Type of widget to use (e.g., \"text\", \"number\").</p> <code>'text'</code> <code>grid_span</code> <code>int</code> <p>Number of grid columns this field spans.</p> <code>1</code> <code>order</code> <code>Optional[int]</code> <p>Optional ordering value for field display.</p> <code>None</code> <code>visible</code> <code>bool</code> <p>Whether the field should be visible in forms.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing field metadata attributes.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def field_metadata(\n    editable: bool = True,\n    label: str = \"\",\n    widget_type: str = \"text\",\n    grid_span: int = 1,\n    order: Optional[int] = None,\n    visible: bool = True,\n) -&gt; Dict[str, Any]:\n    \"\"\"Create field metadata dictionary.\n\n    Convenience function that creates a FieldMetadata instance and converts\n    it to a dictionary suitable for use in dataclass field metadata.\n\n    Args:\n        editable: Whether the field can be edited by the user.\n        label: Display label for the field.\n        widget_type: Type of widget to use (e.g., \"text\", \"number\").\n        grid_span: Number of grid columns this field spans.\n        order: Optional ordering value for field display.\n        visible: Whether the field should be visible in forms.\n\n    Returns:\n        Dictionary containing field metadata attributes.\n    \"\"\"\n    return FieldMetadata(\n        editable=editable,\n        label=label,\n        widget_type=widget_type,\n        grid_span=grid_span,\n        order=order,\n        visible=visible,\n    ).to_dict()\n</code></pre>"},{"location":"api/kym_file/#kymflow_core.kym_file.iter_metadata","title":"<code>iter_metadata(root, *, glob='*.tif', follow_symlinks=False)</code>","text":"<p>Iterate over metadata for all TIFF files under a root directory.</p> <p>Efficiently scans a directory tree for TIFF files and yields metadata dictionaries for each file. Only metadata is loaded - image pixels are not read, making this suitable for browsing large collections.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str | Path</code> <p>Root directory to search, or a single file path.</p> required <code>glob</code> <code>str</code> <p>Glob pattern for matching files. Defaults to \"*.tif\".</p> <code>'*.tif'</code> <code>follow_symlinks</code> <code>bool</code> <p>If True, follow symbolic links when searching. Defaults to False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing metadata for each TIFF file found, including</p> <code>Dict[str, Any]</code> <p>path, filename, Olympus header data, and experiment metadata.</p> <code>Dict[str, Any]</code> <p>Files that cannot be loaded are silently skipped.</p> Source code in <code>src/kymflow_core/kym_file.py</code> <pre><code>def iter_metadata(\n    root: str | Path,\n    *,\n    glob: str = \"*.tif\",\n    follow_symlinks: bool = False,\n) -&gt; Iterator[Dict[str, Any]]:\n    \"\"\"Iterate over metadata for all TIFF files under a root directory.\n\n    Efficiently scans a directory tree for TIFF files and yields metadata\n    dictionaries for each file. Only metadata is loaded - image pixels are\n    not read, making this suitable for browsing large collections.\n\n    Args:\n        root: Root directory to search, or a single file path.\n        glob: Glob pattern for matching files. Defaults to \"*.tif\".\n        follow_symlinks: If True, follow symbolic links when searching.\n            Defaults to False.\n\n    Yields:\n        Dictionary containing metadata for each TIFF file found, including\n        path, filename, Olympus header data, and experiment metadata.\n        Files that cannot be loaded are silently skipped.\n    \"\"\"\n    base = Path(root)\n    paths: Iterable[Path]\n    if base.is_dir():\n        paths = base.rglob(glob) if follow_symlinks else base.glob(f\"**/{glob}\")\n    else:\n        paths = [base]\n\n    for tif_path in paths:\n        if not tif_path.is_file():\n            continue\n        try:\n            kym = KymFile(tif_path, load_image=False)\n            yield kym.to_metadata_dict(include_analysis=False)\n        except Exception:\n            # Metadata collection should be resilient; callers can log errors.\n            continue\n</code></pre>"},{"location":"api/kym_flow_radon_gpt/","title":"kymflow_core.kym_flow_radon_gpt","text":"<p>Radon transform-based flow analysis for kymograph images.</p> <p>This module implements a multiprocessing-capable flow analysis algorithm using Radon transforms to detect flow direction and velocity in kymograph data. The algorithm uses a sliding window approach with coarse and fine angle search to efficiently determine flow angles.</p>"},{"location":"api/kym_flow_radon_gpt/#kymflow_core.kym_flow_radon_gpt-classes","title":"Classes","text":""},{"location":"api/kym_flow_radon_gpt/#kymflow_core.kym_flow_radon_gpt.FlowCancelled","title":"<code>FlowCancelled</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when flow analysis is cancelled.</p> <p>This exception is raised when the analysis is cancelled via the is_cancelled callback during processing.</p> Source code in <code>src/kymflow_core/kym_flow_radon_gpt.py</code> <pre><code>class FlowCancelled(Exception):\n    \"\"\"Exception raised when flow analysis is cancelled.\n\n    This exception is raised when the analysis is cancelled via the\n    is_cancelled callback during processing.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/kym_flow_radon_gpt/#kymflow_core.kym_flow_radon_gpt-functions","title":"Functions","text":""},{"location":"api/kym_flow_radon_gpt/#kymflow_core.kym_flow_radon_gpt.mp_analyze_flow","title":"<code>mp_analyze_flow(data, windowsize, start_pixel=None, stop_pixel=None, *, verbose=False, progress_callback=None, progress_every=1, is_cancelled=None, use_multiprocessing=True, processes=None)</code>","text":"<p>Analyze blood flow in a kymograph using Radon transforms.</p> <p>Performs a sliding window analysis along the time axis to detect flow direction and velocity. Uses a two-stage Radon transform approach: coarse search over 0-179 degrees, then fine refinement around the best angle.</p> Data convention <p>data is a 2D numpy array with shape (time, space), where: - axis 0 (index 0) is time (aka 'lines', 'line scans') - axis 1 (index 1) is space (aka 'pixels')</p> Algorithm <ul> <li>Use a sliding window along the time axis with 25% overlap.</li> <li>For each window, run a coarse Radon transform over 0..179 degrees.</li> <li>Find the angle that maximizes the variance in Radon space.</li> <li>Refine around that angle with a fine grid (\u00b12 degrees, 0.25 step).</li> <li>Return best angles and associated fine spread.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>2D numpy array (time, space) containing the kymograph data.</p> required <code>windowsize</code> <code>int</code> <p>Number of time lines per analysis window. Must be a multiple of 4 (stepsize is 25% of windowsize).</p> required <code>start_pixel</code> <code>Optional[int]</code> <p>Start index in space dimension (axis 1), inclusive. If None, uses 0.</p> <code>None</code> <code>stop_pixel</code> <code>Optional[int]</code> <p>Stop index in space dimension (axis 1), exclusive. If None, uses full width.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If True, prints timing and shape information to stdout.</p> <code>False</code> <code>progress_callback</code> <code>Optional[Callable[[int, int], Any]]</code> <p>Optional callable(completed, total_windows) called periodically to report progress.</p> <code>None</code> <code>progress_every</code> <code>int</code> <p>Emit progress every N completed windows. Defaults to 1.</p> <code>1</code> <code>is_cancelled</code> <code>Optional[Callable[[], bool]]</code> <p>Optional callable() -&gt; bool that returns True if computation should be cancelled.</p> <code>None</code> <code>use_multiprocessing</code> <code>bool</code> <p>If True, uses multiprocessing.Pool for parallel computation. If False, runs sequentially. Defaults to True.</p> <code>True</code> <code>processes</code> <code>Optional[int]</code> <p>Optional number of worker processes. If None, uses cpu_count() - 1 (minimum 1). Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>Tuple containing: - thetas: 1D array (nsteps,) of best angle in degrees per window. - the_t: 1D array (nsteps,) of center time index for each window. - spread_matrix_fine: 2D array (nsteps, len(angles_fine)) of   variance values for fine angles.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data is not 2D or windowsize is invalid.</p> <code>FlowCancelled</code> <p>If is_cancelled() returns True during processing.</p> Source code in <code>src/kymflow_core/kym_flow_radon_gpt.py</code> <pre><code>def mp_analyze_flow(\n    data: np.ndarray,\n    windowsize: int,\n    start_pixel: Optional[int] = None,\n    stop_pixel: Optional[int] = None,\n    *,\n    verbose: bool = False,\n    progress_callback: Optional[Callable[[int, int], Any]] = None,\n    progress_every: int = 1,\n    is_cancelled: Optional[Callable[[], bool]] = None,\n    use_multiprocessing: bool = True,\n    processes: Optional[int] = None,\n):\n    \"\"\"Analyze blood flow in a kymograph using Radon transforms.\n\n    Performs a sliding window analysis along the time axis to detect flow\n    direction and velocity. Uses a two-stage Radon transform approach:\n    coarse search over 0-179 degrees, then fine refinement around the best\n    angle.\n\n    Data convention:\n        data is a 2D numpy array with shape (time, space), where:\n        - axis 0 (index 0) is time (aka 'lines', 'line scans')\n        - axis 1 (index 1) is space (aka 'pixels')\n\n    Algorithm:\n        - Use a sliding window along the time axis with 25% overlap.\n        - For each window, run a coarse Radon transform over 0..179 degrees.\n        - Find the angle that maximizes the variance in Radon space.\n        - Refine around that angle with a fine grid (\u00b12 degrees, 0.25 step).\n        - Return best angles and associated fine spread.\n\n    Args:\n        data: 2D numpy array (time, space) containing the kymograph data.\n        windowsize: Number of time lines per analysis window. Must be a\n            multiple of 4 (stepsize is 25% of windowsize).\n        start_pixel: Start index in space dimension (axis 1), inclusive.\n            If None, uses 0.\n        stop_pixel: Stop index in space dimension (axis 1), exclusive.\n            If None, uses full width.\n        verbose: If True, prints timing and shape information to stdout.\n        progress_callback: Optional callable(completed, total_windows) called\n            periodically to report progress.\n        progress_every: Emit progress every N completed windows. Defaults to 1.\n        is_cancelled: Optional callable() -&gt; bool that returns True if\n            computation should be cancelled.\n        use_multiprocessing: If True, uses multiprocessing.Pool for parallel\n            computation. If False, runs sequentially. Defaults to True.\n        processes: Optional number of worker processes. If None, uses\n            cpu_count() - 1 (minimum 1). Defaults to None.\n\n    Returns:\n        Tuple containing:\n            - thetas: 1D array (nsteps,) of best angle in degrees per window.\n            - the_t: 1D array (nsteps,) of center time index for each window.\n            - spread_matrix_fine: 2D array (nsteps, len(angles_fine)) of\n              variance values for fine angles.\n\n    Raises:\n        ValueError: If data is not 2D or windowsize is invalid.\n        FlowCancelled: If is_cancelled() returns True during processing.\n    \"\"\"\n    start_sec = time.time()\n\n    if data.ndim != 2:\n        raise ValueError(f\"data must be 2D (time, space); got shape {data.shape}\")\n\n    # time axis = 0, space axis = 1\n    n_time = data.shape[0]\n    n_space = data.shape[1]\n\n    stepsize = int(0.25 * windowsize)\n    if stepsize &lt;= 0:\n        raise ValueError(f\"windowsize too small to compute stepsize: {windowsize}\")\n\n    nsteps = math.floor(n_time / stepsize) - 3\n    if nsteps &lt;= 0:\n        raise ValueError(\n            f\"Invalid nsteps={nsteps}. Check windowsize={windowsize} and data.shape={data.shape}\"\n        )\n\n    if start_pixel is None:\n        start_pixel = 0\n    if stop_pixel is None:\n        stop_pixel = n_space\n\n    # Coarse and fine angle grids (degrees)\n    angles = np.arange(180, dtype=np.float32)  # 0..179 degrees\n    fine_step = 0.25\n    angles_fine = np.arange(-2.0, 2.0 + fine_step, fine_step, dtype=np.float32)\n\n    # Outputs\n    thetas = np.zeros(nsteps, dtype=np.float32)\n    the_t = np.ones(nsteps, dtype=np.float32) * np.nan\n    spread_matrix_fine = np.zeros((nsteps, len(angles_fine)), dtype=np.float32)\n\n    if verbose:\n        print(f\"data shape (time, space): {data.shape}\")\n        print(f\"  windowsize: {windowsize}, stepsize: {stepsize}\")\n        print(f\"  n_time: {n_time}, n_space: {n_space}, nsteps: {nsteps}\")\n        print(f\"  start_pixel: {start_pixel}, stop_pixel: {stop_pixel}\")\n\n    completed = 0\n    last_emit = 0\n\n    def cancelled() -&gt; bool:\n        return bool(is_cancelled and is_cancelled())\n\n    def maybe_progress():\n        nonlocal last_emit, completed\n        if progress_callback is None:\n            return\n        if (completed - last_emit) &gt;= max(1, progress_every):\n            try:\n                progress_callback(completed, nsteps)\n            except Exception:\n                # Swallow progress errors; they shouldn't kill the computation.\n                pass\n            last_emit = completed\n\n    # --- Multiprocessing path ---\n    if use_multiprocessing and nsteps &gt; 1:\n        proc_count = processes or (os.cpu_count() or 1) - 1\n        proc_count = max(1, proc_count)\n\n        with Pool(processes=proc_count) as pool:\n            result_objs = []\n\n            # Enqueue all windows\n            for k in range(nsteps):\n                if cancelled():\n                    pool.terminate()\n                    pool.join()\n                    raise FlowCancelled(\n                        \"Flow analysis cancelled before submitting all windows.\"\n                    )\n\n                # Center time index for this window\n                the_t[k] = 1 + k * stepsize + windowsize / 2.0\n\n                t_start = k * stepsize\n                t_stop = k * stepsize + windowsize\n                data_window = data[t_start:t_stop, start_pixel:stop_pixel]\n\n                params = (data_window, angles, angles_fine)\n                result = pool.apply_async(radon_worker, params)\n                result_objs.append(result)\n\n            # Collect results\n            for k, result in enumerate(result_objs):\n                if cancelled():\n                    pool.terminate()\n                    pool.join()\n                    raise FlowCancelled(\n                        \"Flow analysis cancelled while processing windows.\"\n                    )\n\n                worker_theta, worker_spread_fine = result.get()\n                thetas[k] = worker_theta\n                spread_matrix_fine[k, :] = worker_spread_fine\n\n                completed += 1\n                maybe_progress()\n\n    # --- Single-process path (debug / small data) ---\n    else:\n        for k in range(nsteps):\n            if cancelled():\n                raise FlowCancelled(\"Flow analysis cancelled (single-process mode).\")\n\n            the_t[k] = 1 + k * stepsize + windowsize / 2.0\n\n            t_start = k * stepsize\n            t_stop = k * stepsize + windowsize\n            data_window = data[t_start:t_stop, start_pixel:stop_pixel]\n\n            worker_theta, worker_spread_fine = radon_worker(\n                data_window, angles, angles_fine\n            )\n            thetas[k] = worker_theta\n            spread_matrix_fine[k, :] = worker_spread_fine\n\n            completed += 1\n            maybe_progress()\n\n    # Final progress update\n    if progress_callback is not None:\n        try:\n            progress_callback(nsteps, nsteps)\n        except Exception:\n            pass\n\n    if verbose:\n        stop_sec = time.time()\n        print(f\"Flow analysis took {round(stop_sec - start_sec, 2)} seconds\")\n\n    return thetas, the_t, spread_matrix_fine\n</code></pre>"},{"location":"api/kym_flow_radon_gpt/#kymflow_core.kym_flow_radon_gpt.radon_worker","title":"<code>radon_worker(data_window, angles, angles_fine)</code>","text":"<p>Calculate flow angle for a single time window using Radon transforms.</p> <p>This function is designed to be used as a multiprocessing worker. It performs a two-stage Radon transform: first a coarse search over all angles, then a fine search around the best coarse angle.</p> <p>Parameters:</p> Name Type Description Default <code>data_window</code> <code>ndarray</code> <p>2D numpy array (time, space) for this window slice. Time axis is 0, space axis is 1. The mean is subtracted before processing.</p> required <code>angles</code> <code>ndarray</code> <p>1D array of coarse angles in degrees (typically 0-179).</p> required <code>angles_fine</code> <code>ndarray</code> <p>1D array of fine angle offsets in degrees, typically small values around 0 (e.g., -2 to +2 degrees in 0.25 degree steps).</p> required <p>Returns:</p> Type Description <code>Tuple[float, ndarray]</code> <p>Tuple containing: - Best angle in degrees (float) for this window. - 1D array of variance values for each fine angle.</p> Source code in <code>src/kymflow_core/kym_flow_radon_gpt.py</code> <pre><code>def radon_worker(\n    data_window: np.ndarray,\n    angles: np.ndarray,\n    angles_fine: np.ndarray,\n) -&gt; Tuple[float, np.ndarray]:\n    \"\"\"Calculate flow angle for a single time window using Radon transforms.\n\n    This function is designed to be used as a multiprocessing worker. It\n    performs a two-stage Radon transform: first a coarse search over all\n    angles, then a fine search around the best coarse angle.\n\n    Args:\n        data_window: 2D numpy array (time, space) for this window slice.\n            Time axis is 0, space axis is 1. The mean is subtracted before\n            processing.\n        angles: 1D array of coarse angles in degrees (typically 0-179).\n        angles_fine: 1D array of fine angle offsets in degrees, typically\n            small values around 0 (e.g., -2 to +2 degrees in 0.25 degree steps).\n\n    Returns:\n        Tuple containing:\n            - Best angle in degrees (float) for this window.\n            - 1D array of variance values for each fine angle.\n    \"\"\"\n    # Ensure float for radon + mean subtraction\n    data_window = data_window.astype(np.float32, copy=False)\n\n    # Subtract mean over entire window\n    mean_val = float(np.mean(data_window))\n    data_window = data_window - mean_val\n\n    # Coarse radon transform\n    # radon will return shape (len(time_projection), len(angles))\n    radon_coarse = radon(data_window, theta=angles, circle=False)\n    spread_coarse = np.var(radon_coarse, axis=0)  # variance per angle\n\n    # Coarse maximum\n    max_idx = int(np.argmax(spread_coarse))\n    coarse_theta = float(angles[max_idx])\n\n    # Fine search around coarse max\n    fine_angles = coarse_theta + angles_fine\n    radon_fine = radon(data_window, theta=fine_angles, circle=False)\n    spread_fine = np.var(radon_fine, axis=0)\n\n    fine_idx = int(np.argmax(spread_fine))\n    best_theta = coarse_theta + float(angles_fine[fine_idx])\n\n    return best_theta, spread_fine\n</code></pre>"},{"location":"api/repository/","title":"kymflow_core.repository","text":"<p>Repository helpers for discovering and loading kymograph files.</p> <p>This layer isolates filesystem traversal so GUI/CLI code can rely on a single API to fetch <code>KymFile</code> instances or lightweight metadata dictionaries.</p>"},{"location":"api/repository/#kymflow_core.repository-classes","title":"Classes","text":""},{"location":"api/repository/#kymflow_core.repository.FolderScanResult","title":"<code>FolderScanResult</code>  <code>dataclass</code>","text":"<p>Result of scanning a folder for kymograph files.</p> <p>Attributes:</p> Name Type Description <code>folder</code> <code>Path</code> <p>Path to the scanned folder.</p> <code>files</code> <code>List[KymFile]</code> <p>List of KymFile instances found in the folder.</p> Source code in <code>src/kymflow_core/repository.py</code> <pre><code>@dataclass\nclass FolderScanResult:\n    \"\"\"Result of scanning a folder for kymograph files.\n\n    Attributes:\n        folder: Path to the scanned folder.\n        files: List of KymFile instances found in the folder.\n    \"\"\"\n\n    folder: Path\n    files: List[KymFile]\n</code></pre>"},{"location":"api/repository/#kymflow_core.repository-functions","title":"Functions","text":""},{"location":"api/repository/#kymflow_core.repository.metadata_table","title":"<code>metadata_table(folder)</code>","text":"<p>Get metadata dictionaries for all TIFF files in a folder.</p> <p>Lightweight alternative to scan_folder() that returns metadata dictionaries instead of KymFile objects. Useful for quickly populating tables without the overhead of instantiating full KymFile objects.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path</code> <p>Directory path to scan for TIFF files.</p> required <p>Returns:</p> Type Description <code>Sequence[dict]</code> <p>Sequence of metadata dictionaries, one per TIFF file found.</p> Source code in <code>src/kymflow_core/repository.py</code> <pre><code>def metadata_table(folder: str | Path) -&gt; Sequence[dict]:\n    \"\"\"Get metadata dictionaries for all TIFF files in a folder.\n\n    Lightweight alternative to scan_folder() that returns metadata dictionaries\n    instead of KymFile objects. Useful for quickly populating tables without\n    the overhead of instantiating full KymFile objects.\n\n    Args:\n        folder: Directory path to scan for TIFF files.\n\n    Returns:\n        Sequence of metadata dictionaries, one per TIFF file found.\n    \"\"\"\n    return collect_metadata(folder)\n</code></pre>"},{"location":"api/repository/#kymflow_core.repository.scan_folder","title":"<code>scan_folder(folder, *, load_images=False)</code>","text":"<p>Scan a folder for kymograph TIFF files.</p> <p>Creates KymFile objects for every .tif file found in the specified folder. The scan is non-recursive (only direct children of the folder are checked).</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path</code> <p>Directory path to scan for TIFF files.</p> required <code>load_images</code> <code>bool</code> <p>If True, TIFF image arrays are loaded immediately. If False, images are loaded lazily when accessed. Defaults to False for efficient metadata-only workflows.</p> <code>False</code> <p>Returns:</p> Type Description <code>FolderScanResult</code> <p>FolderScanResult containing the folder path and list of KymFile</p> <code>FolderScanResult</code> <p>instances found.</p> Source code in <code>src/kymflow_core/repository.py</code> <pre><code>def scan_folder(folder: str | Path, *, load_images: bool = False) -&gt; FolderScanResult:\n    \"\"\"Scan a folder for kymograph TIFF files.\n\n    Creates KymFile objects for every .tif file found in the specified folder.\n    The scan is non-recursive (only direct children of the folder are checked).\n\n    Args:\n        folder: Directory path to scan for TIFF files.\n        load_images: If True, TIFF image arrays are loaded immediately.\n            If False, images are loaded lazily when accessed. Defaults to False\n            for efficient metadata-only workflows.\n\n    Returns:\n        FolderScanResult containing the folder path and list of KymFile\n        instances found.\n    \"\"\"\n    base = Path(folder)\n    tif_paths = sorted(path for path in base.glob(\"*.tif\") if path.is_file())\n    files = [KymFile(path, load_image=load_images) for path in tif_paths]\n    return FolderScanResult(folder=base, files=files)\n</code></pre>"},{"location":"api/state/","title":"kymflow_core.state","text":"<p>Psygnal-powered state containers shared between GUI components.</p>"},{"location":"api/state/#kymflow_core.state-classes","title":"Classes","text":""},{"location":"api/state/#kymflow_core.state.AppState","title":"<code>AppState</code>","text":"<p>               Bases: <code>EventedModel</code></p> <p>Shared application state for the NiceGUI GUI.</p> <p>Manages the current folder, file list, selected file, theme, and image display parameters. Provides signals for state changes to coordinate updates across GUI components.</p> <p>Attributes:</p> Name Type Description <code>folder</code> <code>Optional[Path]</code> <p>Currently selected folder path.</p> <code>files</code> <code>List[KymFile]</code> <p>List of KymFile instances in the current folder.</p> <code>selected_file</code> <code>Optional[KymFile]</code> <p>Currently selected KymFile, or None.</p> <code>theme_mode</code> <code>ThemeMode</code> <p>Current UI theme (dark or light).</p> Signals <p>file_list_changed: Emitted when the file list is updated. selection_changed: Emitted when the selected file changes     (kym_file, origin). metadata_changed: Emitted when file metadata is updated (kym_file). theme_changed: Emitted when theme changes (ThemeMode). image_display_changed: Emitted when image display parameters change     (ImageDisplayParams).</p> Source code in <code>src/kymflow_core/state.py</code> <pre><code>class AppState(EventedModel):\n    \"\"\"Shared application state for the NiceGUI GUI.\n\n    Manages the current folder, file list, selected file, theme, and image\n    display parameters. Provides signals for state changes to coordinate\n    updates across GUI components.\n\n    Attributes:\n        folder: Currently selected folder path.\n        files: List of KymFile instances in the current folder.\n        selected_file: Currently selected KymFile, or None.\n        theme_mode: Current UI theme (dark or light).\n\n    Signals:\n        file_list_changed: Emitted when the file list is updated.\n        selection_changed: Emitted when the selected file changes\n            (kym_file, origin).\n        metadata_changed: Emitted when file metadata is updated (kym_file).\n        theme_changed: Emitted when theme changes (ThemeMode).\n        image_display_changed: Emitted when image display parameters change\n            (ImageDisplayParams).\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    folder: Optional[Path] = None\n    files: List[KymFile] = Field(default_factory=list)\n    selected_file: Optional[KymFile] = None\n    theme_mode: ThemeMode = ThemeMode.DARK\n\n    file_list_changed: ClassVar[Signal] = Signal()\n    selection_changed: ClassVar[Signal] = Signal(object, object)\n    metadata_changed: ClassVar[Signal] = Signal(object)\n    theme_changed: ClassVar[Signal] = Signal(object)\n    image_display_changed: ClassVar[Signal] = Signal(object)\n\n    def load_folder(self, folder: Path) -&gt; FolderScanResult:\n        \"\"\"Scan folder for kymograph files and update app state.\n\n        Scans the specified folder for TIFF files, creates KymFile instances,\n        and updates the app state. Automatically selects the first file if\n        files are found. Emits file_list_changed signal.\n\n        Args:\n            folder: Path to the folder to scan.\n\n        Returns:\n            FolderScanResult containing the scanned folder and file list.\n        \"\"\"\n        result = scan_folder(folder)\n        self.folder = result.folder\n        self.files = result.files\n\n        logger.info(\"--&gt; emit file_list_changed\")\n        self.file_list_changed.emit()\n\n        if self.files:\n            self.select_file(self.files[0])\n        else:\n            self.select_file(None)\n        return result\n\n    def select_file(\n        self,\n        kym_file: Optional[KymFile],\n        origin: Optional[SelectionOrigin] = None,\n    ) -&gt; None:\n        \"\"\"Set the currently selected file and emit selection_changed signal.\n\n        Updates the selected file and emits a signal to notify GUI components.\n        If the file is already selected, no signal is emitted.\n\n        Args:\n            kym_file: KymFile to select, or None to clear selection.\n            origin: Source of the selection change (for avoiding feedback loops).\n                Defaults to None.\n        \"\"\"\n        if self.selected_file is kym_file:\n            return\n        self.selected_file = kym_file\n\n        logger.info(f\"--&gt; emit selection_changed kym_file: {kym_file} origin: {origin}\")\n        self.selection_changed.emit(kym_file, origin)\n\n    def notify_metadata_changed(self, kym_file: KymFile) -&gt; None:\n        \"\"\"Notify listeners that file metadata has been updated.\n\n        Emits metadata_changed signal to notify GUI components that metadata\n        for the specified file has been modified.\n\n        Args:\n            kym_file: KymFile whose metadata was updated.\n        \"\"\"\n        logger.info(f\"--&gt; emit metadata_changed kym_file: {kym_file}\")\n        self.metadata_changed.emit(kym_file)\n\n    def refresh_file_rows(self) -&gt; None:\n        \"\"\"Notify listeners that file metadata changed without reloading folder.\n\n        Emits file_list_changed signal to refresh file table displays without\n        re-scanning the folder. Useful when metadata is updated but the file\n        list itself hasn't changed.\n        \"\"\"\n        logger.info(\"--&gt; emit file_list_changed\")\n        self.file_list_changed.emit()\n\n    def set_theme(self, mode: ThemeMode) -&gt; None:\n        \"\"\"Set the application theme and emit theme_changed signal.\n\n        Updates the theme mode and notifies GUI components. If the theme\n        is already set to the specified mode, no signal is emitted.\n\n        Args:\n            mode: Theme mode to set (DARK or LIGHT).\n        \"\"\"\n        if self.theme_mode == mode:\n            return\n        self.theme_mode = mode\n        logger.info(f\"--&gt; emit theme_changed mode: {mode}\")\n        self.theme_changed.emit(mode)\n\n    def set_image_display(self, params: ImageDisplayParams) -&gt; None:\n        \"\"\"Emit signal to update image display parameters (colorscale, intensity range).\n\n        Args:\n            params: Complete event payload containing colorscale, zmin, zmax, and origin.\n        \"\"\"\n        logger.info(f\"--&gt; emit image_display_changed {params}\")\n        self.image_display_changed.emit(params)\n</code></pre>"},{"location":"api/state/#kymflow_core.state.AppState-functions","title":"Functions","text":""},{"location":"api/state/#kymflow_core.state.AppState.load_folder","title":"<code>load_folder(folder)</code>","text":"<p>Scan folder for kymograph files and update app state.</p> <p>Scans the specified folder for TIFF files, creates KymFile instances, and updates the app state. Automatically selects the first file if files are found. Emits file_list_changed signal.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>Path</code> <p>Path to the folder to scan.</p> required <p>Returns:</p> Type Description <code>FolderScanResult</code> <p>FolderScanResult containing the scanned folder and file list.</p> Source code in <code>src/kymflow_core/state.py</code> <pre><code>def load_folder(self, folder: Path) -&gt; FolderScanResult:\n    \"\"\"Scan folder for kymograph files and update app state.\n\n    Scans the specified folder for TIFF files, creates KymFile instances,\n    and updates the app state. Automatically selects the first file if\n    files are found. Emits file_list_changed signal.\n\n    Args:\n        folder: Path to the folder to scan.\n\n    Returns:\n        FolderScanResult containing the scanned folder and file list.\n    \"\"\"\n    result = scan_folder(folder)\n    self.folder = result.folder\n    self.files = result.files\n\n    logger.info(\"--&gt; emit file_list_changed\")\n    self.file_list_changed.emit()\n\n    if self.files:\n        self.select_file(self.files[0])\n    else:\n        self.select_file(None)\n    return result\n</code></pre>"},{"location":"api/state/#kymflow_core.state.AppState.notify_metadata_changed","title":"<code>notify_metadata_changed(kym_file)</code>","text":"<p>Notify listeners that file metadata has been updated.</p> <p>Emits metadata_changed signal to notify GUI components that metadata for the specified file has been modified.</p> <p>Parameters:</p> Name Type Description Default <code>kym_file</code> <code>KymFile</code> <p>KymFile whose metadata was updated.</p> required Source code in <code>src/kymflow_core/state.py</code> <pre><code>def notify_metadata_changed(self, kym_file: KymFile) -&gt; None:\n    \"\"\"Notify listeners that file metadata has been updated.\n\n    Emits metadata_changed signal to notify GUI components that metadata\n    for the specified file has been modified.\n\n    Args:\n        kym_file: KymFile whose metadata was updated.\n    \"\"\"\n    logger.info(f\"--&gt; emit metadata_changed kym_file: {kym_file}\")\n    self.metadata_changed.emit(kym_file)\n</code></pre>"},{"location":"api/state/#kymflow_core.state.AppState.refresh_file_rows","title":"<code>refresh_file_rows()</code>","text":"<p>Notify listeners that file metadata changed without reloading folder.</p> <p>Emits file_list_changed signal to refresh file table displays without re-scanning the folder. Useful when metadata is updated but the file list itself hasn't changed.</p> Source code in <code>src/kymflow_core/state.py</code> <pre><code>def refresh_file_rows(self) -&gt; None:\n    \"\"\"Notify listeners that file metadata changed without reloading folder.\n\n    Emits file_list_changed signal to refresh file table displays without\n    re-scanning the folder. Useful when metadata is updated but the file\n    list itself hasn't changed.\n    \"\"\"\n    logger.info(\"--&gt; emit file_list_changed\")\n    self.file_list_changed.emit()\n</code></pre>"},{"location":"api/state/#kymflow_core.state.AppState.select_file","title":"<code>select_file(kym_file, origin=None)</code>","text":"<p>Set the currently selected file and emit selection_changed signal.</p> <p>Updates the selected file and emits a signal to notify GUI components. If the file is already selected, no signal is emitted.</p> <p>Parameters:</p> Name Type Description Default <code>kym_file</code> <code>Optional[KymFile]</code> <p>KymFile to select, or None to clear selection.</p> required <code>origin</code> <code>Optional[SelectionOrigin]</code> <p>Source of the selection change (for avoiding feedback loops). Defaults to None.</p> <code>None</code> Source code in <code>src/kymflow_core/state.py</code> <pre><code>def select_file(\n    self,\n    kym_file: Optional[KymFile],\n    origin: Optional[SelectionOrigin] = None,\n) -&gt; None:\n    \"\"\"Set the currently selected file and emit selection_changed signal.\n\n    Updates the selected file and emits a signal to notify GUI components.\n    If the file is already selected, no signal is emitted.\n\n    Args:\n        kym_file: KymFile to select, or None to clear selection.\n        origin: Source of the selection change (for avoiding feedback loops).\n            Defaults to None.\n    \"\"\"\n    if self.selected_file is kym_file:\n        return\n    self.selected_file = kym_file\n\n    logger.info(f\"--&gt; emit selection_changed kym_file: {kym_file} origin: {origin}\")\n    self.selection_changed.emit(kym_file, origin)\n</code></pre>"},{"location":"api/state/#kymflow_core.state.AppState.set_image_display","title":"<code>set_image_display(params)</code>","text":"<p>Emit signal to update image display parameters (colorscale, intensity range).</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ImageDisplayParams</code> <p>Complete event payload containing colorscale, zmin, zmax, and origin.</p> required Source code in <code>src/kymflow_core/state.py</code> <pre><code>def set_image_display(self, params: ImageDisplayParams) -&gt; None:\n    \"\"\"Emit signal to update image display parameters (colorscale, intensity range).\n\n    Args:\n        params: Complete event payload containing colorscale, zmin, zmax, and origin.\n    \"\"\"\n    logger.info(f\"--&gt; emit image_display_changed {params}\")\n    self.image_display_changed.emit(params)\n</code></pre>"},{"location":"api/state/#kymflow_core.state.AppState.set_theme","title":"<code>set_theme(mode)</code>","text":"<p>Set the application theme and emit theme_changed signal.</p> <p>Updates the theme mode and notifies GUI components. If the theme is already set to the specified mode, no signal is emitted.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ThemeMode</code> <p>Theme mode to set (DARK or LIGHT).</p> required Source code in <code>src/kymflow_core/state.py</code> <pre><code>def set_theme(self, mode: ThemeMode) -&gt; None:\n    \"\"\"Set the application theme and emit theme_changed signal.\n\n    Updates the theme mode and notifies GUI components. If the theme\n    is already set to the specified mode, no signal is emitted.\n\n    Args:\n        mode: Theme mode to set (DARK or LIGHT).\n    \"\"\"\n    if self.theme_mode == mode:\n        return\n    self.theme_mode = mode\n    logger.info(f\"--&gt; emit theme_changed mode: {mode}\")\n    self.theme_changed.emit(mode)\n</code></pre>"},{"location":"api/state/#kymflow_core.state.ImageDisplayParams","title":"<code>ImageDisplayParams</code>  <code>dataclass</code>","text":"<p>Event payload for image display parameter changes.</p> <p>Contains all information about display parameter changes, including which UI element initiated the change. Used to coordinate image display updates across GUI components.</p> <p>Attributes:</p> Name Type Description <code>colorscale</code> <code>str</code> <p>Name of the color scale to use (e.g., \"viridis\", \"gray\").</p> <code>zmin</code> <code>Optional[int]</code> <p>Minimum intensity value for display scaling. If None, uses data minimum.</p> <code>zmax</code> <code>Optional[int]</code> <p>Maximum intensity value for display scaling. If None, uses data maximum.</p> <code>origin</code> <code>ImageDisplayOrigin</code> <p>Source of the display parameter change (for avoiding feedback loops).</p> Source code in <code>src/kymflow_core/state.py</code> <pre><code>@dataclass\nclass ImageDisplayParams:\n    \"\"\"Event payload for image display parameter changes.\n\n    Contains all information about display parameter changes, including\n    which UI element initiated the change. Used to coordinate image display\n    updates across GUI components.\n\n    Attributes:\n        colorscale: Name of the color scale to use (e.g., \"viridis\", \"gray\").\n        zmin: Minimum intensity value for display scaling. If None, uses\n            data minimum.\n        zmax: Maximum intensity value for display scaling. If None, uses\n            data maximum.\n        origin: Source of the display parameter change (for avoiding feedback loops).\n    \"\"\"\n\n    colorscale: str\n    zmin: Optional[int] = None\n    zmax: Optional[int] = None\n    origin: ImageDisplayOrigin = ImageDisplayOrigin.OTHER\n\n    def __str__(self) -&gt; str:\n        return f\"ImageDisplayParams(colorscale: {self.colorscale}, zmin: {self.zmin}, zmax: {self.zmax}, origin: {self.origin})\"\n</code></pre>"},{"location":"api/state/#kymflow_core.state.TaskState","title":"<code>TaskState</code>","text":"<p>               Bases: <code>EventedModel</code></p> <p>Container for tracking long-running UI tasks with progress.</p> <p>Provides signals for progress updates, cancellation, and completion. Used to coordinate between background threads and GUI components.</p> <p>Attributes:</p> Name Type Description <code>running</code> <code>bool</code> <p>Whether a task is currently running.</p> <code>progress</code> <code>float</code> <p>Progress value between 0.0 and 1.0.</p> <code>message</code> <code>str</code> <p>Status message describing current task state.</p> <code>cancellable</code> <code>bool</code> <p>Whether the task can be cancelled.</p> Signals <p>progress_changed: Emitted when progress value changes (float). cancelled: Emitted when cancellation is requested. finished: Emitted when task completes.</p> Source code in <code>src/kymflow_core/state.py</code> <pre><code>class TaskState(EventedModel):\n    \"\"\"Container for tracking long-running UI tasks with progress.\n\n    Provides signals for progress updates, cancellation, and completion.\n    Used to coordinate between background threads and GUI components.\n\n    Attributes:\n        running: Whether a task is currently running.\n        progress: Progress value between 0.0 and 1.0.\n        message: Status message describing current task state.\n        cancellable: Whether the task can be cancelled.\n\n    Signals:\n        progress_changed: Emitted when progress value changes (float).\n        cancelled: Emitted when cancellation is requested.\n        finished: Emitted when task completes.\n    \"\"\"\n\n    running: bool = False\n    progress: float = 0.0\n    message: str = \"\"\n    cancellable: bool = False\n\n    progress_changed: ClassVar[Signal] = Signal(float)\n    cancelled: ClassVar[Signal] = Signal()\n    finished: ClassVar[Signal] = Signal()\n\n    def set_progress(self, value: float, message: str = \"\") -&gt; None:\n        \"\"\"Update task progress and emit progress_changed signal.\n\n        Args:\n            value: Progress value between 0.0 and 1.0.\n            message: Optional status message describing current progress.\n        \"\"\"\n        self.progress = value\n        self.message = message\n        self.progress_changed.emit(value)\n\n    def request_cancel(self) -&gt; None:\n        \"\"\"Request cancellation of the current task.\n\n        Emits the cancelled signal if a task is currently running.\n        The task implementation should check for cancellation and stop\n        processing when this is called.\n        \"\"\"\n        if not self.running:\n            return\n        self.cancelled.emit()\n</code></pre>"},{"location":"api/state/#kymflow_core.state.TaskState-functions","title":"Functions","text":""},{"location":"api/state/#kymflow_core.state.TaskState.request_cancel","title":"<code>request_cancel()</code>","text":"<p>Request cancellation of the current task.</p> <p>Emits the cancelled signal if a task is currently running. The task implementation should check for cancellation and stop processing when this is called.</p> Source code in <code>src/kymflow_core/state.py</code> <pre><code>def request_cancel(self) -&gt; None:\n    \"\"\"Request cancellation of the current task.\n\n    Emits the cancelled signal if a task is currently running.\n    The task implementation should check for cancellation and stop\n    processing when this is called.\n    \"\"\"\n    if not self.running:\n        return\n    self.cancelled.emit()\n</code></pre>"},{"location":"api/state/#kymflow_core.state.TaskState.set_progress","title":"<code>set_progress(value, message='')</code>","text":"<p>Update task progress and emit progress_changed signal.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Progress value between 0.0 and 1.0.</p> required <code>message</code> <code>str</code> <p>Optional status message describing current progress.</p> <code>''</code> Source code in <code>src/kymflow_core/state.py</code> <pre><code>def set_progress(self, value: float, message: str = \"\") -&gt; None:\n    \"\"\"Update task progress and emit progress_changed signal.\n\n    Args:\n        value: Progress value between 0.0 and 1.0.\n        message: Optional status message describing current progress.\n    \"\"\"\n    self.progress = value\n    self.message = message\n    self.progress_changed.emit(value)\n</code></pre>"},{"location":"api/state/#kymflow_core.state-functions","title":"Functions","text":""},{"location":"examples/notebooks/","title":"Example Notebooks","text":"<p>Jupyter notebooks demonstrating how to use the KymFlow Python API.</p>"},{"location":"examples/notebooks/#available-notebooks","title":"Available Notebooks","text":"<p>Notebooks are located in the <code>notebooks/</code> directory of the repository:</p> <ul> <li><code>display_one_kym.py</code> - Example script for displaying a single kymograph</li> <li><code>quality_control.ipynb</code> - Quality control workflow</li> </ul>"},{"location":"examples/notebooks/#running-notebooks","title":"Running Notebooks","text":"<ol> <li> <p>Install notebook dependencies:    <pre><code>pip install kymflow[notebook]\n</code></pre></p> </li> <li> <p>Launch Jupyter Lab:    <pre><code>jupyter lab --notebook-dir notebooks\n</code></pre></p> </li> <li> <p>Open and run the notebooks to see examples of:</p> </li> <li>Loading kymograph files</li> <li>Accessing metadata</li> <li>Running flow analysis</li> <li>Visualizing results</li> </ol>"},{"location":"examples/notebooks/#example-code","title":"Example Code","text":"<pre><code>from kymflow_core.kym_file import KymFile\n\n# Load a kymograph file\nkym = KymFile(\"path/to/file.tif\", load_image=False)\n\n# Access metadata\nprint(f\"Duration: {kym.duration_seconds} seconds\")\nprint(f\"Pixels per line: {kym.pixels_per_line}\")\n\n# Load image when needed\nimage = kym.ensure_image_loaded()\n\n# Run analysis\nkym.analyze_flow(window_size=16)\n\n# Save results\nkym.save_analysis()\n</code></pre>"},{"location":"user-guide/batch-processing/","title":"Batch Processing","text":"<p>Batch processing allows you to analyze multiple kymograph files sequentially with progress tracking.</p>"},{"location":"user-guide/batch-processing/#workflow","title":"Workflow","text":"<ol> <li>Navigate to Batch Page: Click \"Batch\" in the header navigation</li> <li>Select Files:</li> <li>Click multiple rows to select files (multi-select mode)</li> <li>Selection counter shows number of selected files</li> <li>Set Parameters: Choose window size for analysis</li> <li>Start Analysis: Click \"Analyze Flow\" button</li> <li>Monitor Progress:</li> <li>Overall progress shows files completed</li> <li>Per-file progress shows windows completed for current file</li> <li>Save Results: Files are marked as analyzed; use Save button to persist</li> </ol>"},{"location":"user-guide/batch-processing/#features","title":"Features","text":"<ul> <li>Progress Tracking: Two progress bars - one for overall batch, one for current file</li> <li>Cancellation: Cancel button stops processing at any time</li> <li>Auto-Refresh: File table updates as each file completes</li> <li>Error Handling: If one file fails, processing continues with remaining files</li> </ul>"},{"location":"user-guide/batch-processing/#tips","title":"Tips","text":"<ul> <li>Start with a small selection to test parameters</li> <li>Window size applies to all files in the batch</li> <li>Results are not auto-saved - use Save button after batch completes</li> <li>Large batches may take significant time depending on file sizes</li> </ul>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":""},{"location":"user-guide/getting-started/#first-steps","title":"First Steps","text":"<ol> <li>Launch KymFlow: Run <code>kymflow-gui</code> from your terminal</li> <li>Select a Folder: Use the folder selector to choose a directory containing kymograph TIFF files</li> <li>Browse Files: The file table shows all TIFF files found in the selected folder</li> <li>Select a File: Click on a file in the table to view its metadata and image</li> </ol>"},{"location":"user-guide/getting-started/#basic-workflow","title":"Basic Workflow","text":""},{"location":"user-guide/getting-started/#viewing-files","title":"Viewing Files","text":"<ul> <li>The file table displays key metadata for each file</li> <li>Select a file to see detailed metadata, image, and analysis results</li> <li>Use the image viewer to explore the kymograph data</li> </ul>"},{"location":"user-guide/getting-started/#editing-metadata","title":"Editing Metadata","text":"<ol> <li>Select a file from the table</li> <li>Edit fields in the Metadata section (species, region, notes, etc.)</li> <li>Changes are saved automatically when you save the analysis</li> </ol>"},{"location":"user-guide/getting-started/#running-analysis","title":"Running Analysis","text":"<ol> <li>Select a file</li> <li>Set the window size (typically 16, 32, 64, 128, or 256)</li> <li>Click \"Analyze Flow\" in the toolbar</li> <li>Wait for analysis to complete</li> <li>Click \"Save\" to persist results</li> </ol>"},{"location":"user-guide/getting-started/#batch-processing","title":"Batch Processing","text":"<ol> <li>Navigate to the Batch page</li> <li>Select multiple files (hold Ctrl/Cmd to multi-select)</li> <li>Set window size</li> <li>Click \"Analyze Flow\" to process all selected files sequentially</li> </ol>"},{"location":"user-guide/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>See GUI Usage for detailed interface documentation</li> <li>See Batch Processing for batch analysis workflows</li> <li>See API Reference for programmatic access</li> </ul>"},{"location":"user-guide/gui-usage/","title":"GUI Usage Guide","text":""},{"location":"user-guide/gui-usage/#main-page","title":"Main Page","text":"<p>The main page provides a complete workflow for analyzing individual kymograph files.</p>"},{"location":"user-guide/gui-usage/#file-table","title":"File Table","text":"<ul> <li>Single Selection: Click a row to select a file</li> <li>Columns: File name, folder info, analysis status, metadata preview</li> <li>Status Indicators: \u2713 marks show if file is analyzed and saved</li> </ul>"},{"location":"user-guide/gui-usage/#image-line-viewer","title":"Image &amp; Line Viewer","text":"<ul> <li>Kymograph Display: Shows the 2D kymograph image</li> <li>Line Plot: Shows velocity over time from analysis</li> <li>Zoom/Pan: Use mouse to zoom and pan the image</li> <li>Contrast Controls: Adjust intensity scaling</li> </ul>"},{"location":"user-guide/gui-usage/#metadata-forms","title":"Metadata Forms","text":"<ul> <li>Experimental Metadata: Edit species, region, cell type, depth, branch order, direction, sex, genotype, condition, and notes</li> <li>Olympus Header: View acquisition parameters (read-only)</li> <li>Analysis Parameters: View analysis settings and results (read-only)</li> </ul>"},{"location":"user-guide/gui-usage/#analysis-toolbar","title":"Analysis Toolbar","text":"<ul> <li>Window Size: Select analysis window size (16, 32, 64, 128, 256)</li> <li>Analyze Flow: Run Radon-based flow analysis</li> <li>Cancel: Stop running analysis</li> <li>Save: Save analysis results to disk</li> </ul>"},{"location":"user-guide/gui-usage/#batch-page","title":"Batch Page","text":"<p>The batch page allows processing multiple files sequentially.</p>"},{"location":"user-guide/gui-usage/#multi-selection","title":"Multi-Selection","text":"<ul> <li>Select Multiple Files: Click multiple rows to select them</li> <li>Selection Counter: Shows number of selected files</li> <li>Analyze Selected: Process only selected files</li> <li>Progress Tracking: See progress for both individual files and overall batch</li> </ul>"},{"location":"user-guide/gui-usage/#batch-controls","title":"Batch Controls","text":"<ul> <li>Window Size: Set analysis window size for all files</li> <li>Analyze Flow: Start batch processing</li> <li>Cancel: Stop batch processing at any time</li> </ul>"},{"location":"user-guide/gui-usage/#tips","title":"Tips","text":"<ul> <li>Use the folder selector to switch between different data directories</li> <li>Analysis results are saved in a <code>-analysis</code> subfolder alongside your TIFF files</li> <li>The GUI preserves your file selections when navigating between pages</li> <li>Use the contrast controls to better visualize flow patterns in the image</li> </ul>"},{"location":"user-guide/installation/","title":"Installation","text":""},{"location":"user-guide/installation/#quick-start","title":"Quick Start","text":""},{"location":"user-guide/installation/#create-virtual-environment","title":"Create Virtual Environment","text":"<pre><code>python -m venv venv\n</code></pre>"},{"location":"user-guide/installation/#activate-virtual-environment","title":"Activate Virtual Environment","text":"<p>On macOS/Linux: <pre><code>source venv/bin/activate\n</code></pre></p> <p>On Windows: <pre><code>venv\\Scripts\\activate\n</code></pre></p>"},{"location":"user-guide/installation/#install-kymflow-with-gui","title":"Install KymFlow with GUI","text":"<pre><code>pip install kymflow[gui]\n</code></pre>"},{"location":"user-guide/installation/#run-the-gui","title":"Run the GUI","text":"<pre><code>kymflow-gui\n</code></pre> <p>The GUI will open in your default web browser at <code>http://localhost:8080</code> (or the next available port).</p>"},{"location":"user-guide/installation/#installation-options","title":"Installation Options","text":""},{"location":"user-guide/installation/#gui-application-only","title":"GUI Application Only","text":"<pre><code>pip install kymflow[gui]\n</code></pre>"},{"location":"user-guide/installation/#python-api-only-no-gui","title":"Python API Only (No GUI)","text":"<pre><code>pip install kymflow\n</code></pre>"},{"location":"user-guide/installation/#development-installation","title":"Development Installation","text":"<p>For development, install in editable mode with all extras:</p> <pre><code>git clone https://github.com/mapmanager/kymflow.git\ncd kymflow\npip install -e \".[gui,test,notebook]\"\n</code></pre>"},{"location":"user-guide/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or higher</li> <li>See <code>pyproject.toml</code> for full dependency list</li> </ul>"}]}